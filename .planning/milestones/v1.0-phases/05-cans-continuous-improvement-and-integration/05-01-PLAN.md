---
phase: 05-cans-continuous-improvement-and-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/refinement/types.ts
  - src/refinement/observation-store.ts
  - src/refinement/proposal-queue.ts
  - src/refinement/pattern-matcher.ts
  - src/refinement/proposal-generator.ts
  - test/unit/refinement/observation-store.test.ts
  - test/unit/refinement/pattern-matcher.test.ts
  - test/unit/refinement/proposal-generator.test.ts
autonomous: true
requirements:
  - CANS-08

must_haves:
  truths:
    - "Usage observations are recorded as append-only JSONL in .careagent/observations.jsonl"
    - "Divergence patterns are detected only when 5+ observations of the same field divergence exist"
    - "Scope fields (scope.*) are never included in divergence detection or proposal generation"
    - "Proposals include both a human-readable evidence summary and current/proposed values"
    - "Proposal queue persists to .careagent/proposals.json with pending/accepted/rejected/deferred statuses"
  artifacts:
    - path: "src/refinement/types.ts"
      provides: "Observation, Proposal, DivergencePattern, ObservationCategory types"
      contains: "ObservationCategory"
    - path: "src/refinement/observation-store.ts"
      provides: "Append-only JSONL observation storage"
      exports: ["ObservationStore"]
    - path: "src/refinement/proposal-queue.ts"
      provides: "Proposal lifecycle management with JSON persistence"
      exports: ["ProposalQueue"]
    - path: "src/refinement/pattern-matcher.ts"
      provides: "Field-category divergence detection with scope field exclusion"
      exports: ["detectDivergences"]
    - path: "src/refinement/proposal-generator.ts"
      provides: "Creates proposals from detected divergence patterns"
      exports: ["generateProposals"]
  key_links:
    - from: "src/refinement/pattern-matcher.ts"
      to: "src/refinement/types.ts"
      via: "SACROSANCT_FIELDS exclusion check"
      pattern: "isScopeField|SACROSANCT"
    - from: "src/refinement/proposal-generator.ts"
      to: "src/refinement/pattern-matcher.ts"
      via: "Uses detectDivergences output to create Proposal objects"
      pattern: "detectDivergences|DivergencePattern"
    - from: "src/refinement/observation-store.ts"
      to: ".careagent/observations.jsonl"
      via: "appendFileSync for append-only writes"
      pattern: "appendFileSync.*observations\\.jsonl"
---

<objective>
Build the refinement engine's foundational components: types, observation store, proposal queue, pattern matcher, and proposal generator.

Purpose: These components form the data layer and pattern detection logic of the CANS refinement system. Observations record provider behavior divergences, the pattern matcher identifies statistically significant divergences (5+ threshold), and the proposal generator creates human-readable proposals with evidence summaries. Scope fields are hard-excluded at multiple layers as a safety invariant.

Output: Five source modules in `src/refinement/` with comprehensive unit tests.
</objective>

<execution_context>
@/Users/medomatic/.claude/get-shit-done/workflows/execute-plan.md
@/Users/medomatic/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-cans-continuous-improvement-and-integration/05-RESEARCH.md
@src/activation/cans-schema.ts
@src/activation/cans-parser.ts
@src/audit/pipeline.ts
@test/fixtures/valid-cans-data.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create refinement types, observation store, and proposal queue</name>
  <files>
    src/refinement/types.ts
    src/refinement/observation-store.ts
    src/refinement/proposal-queue.ts
    test/unit/refinement/observation-store.test.ts
  </files>
  <action>
    Create `src/refinement/types.ts` with all refinement system types:
    - `ObservationCategory` union type: `'voice' | 'autonomy' | 'credential' | 'skill_usage' | 'identity'`
    - `Observation` interface: `timestamp: string`, `session_id: string`, `category: ObservationCategory`, `field_path: string`, `declared_value: unknown`, `observed_value: unknown`, `context?: string`
    - `DivergencePattern` interface: `field_path: string`, `category: ObservationCategory`, `observation_count: number`, `declared_value: unknown`, `most_common_observed: unknown`, `evidence_summary: string`
    - `Proposal` interface: `id: string`, `created_at: string`, `field_path: string`, `category: ObservationCategory`, `current_value: unknown`, `proposed_value: unknown`, `evidence_summary: string`, `observation_count: number`, `status: 'pending' | 'accepted' | 'rejected' | 'deferred'`, `resolved_at?: string`, `rejection_count?: number`
    - `ProposalResolution` type: `'accept' | 'reject' | 'defer'`
    - `CATEGORY_FIELDS` record mapping each ObservationCategory to its CANS field paths (per research code example)
    - `SACROSANCT_FIELDS` Set: `'scope'`, `'scope.permitted_actions'`, `'scope.prohibited_actions'`, `'scope.institutional_limitations'`
    - `isScopeField(fieldPath: string): boolean` — returns true if fieldPath is or starts with `scope.` or equals `scope`
    - Export `DEFAULT_DIVERGENCE_THRESHOLD = 5` and `RESURFACE_THRESHOLD = 10` constants

    Create `src/refinement/observation-store.ts`:
    - `ObservationStore` class constructor takes `workspacePath: string`
    - Store path: `join(workspacePath, '.careagent', 'observations.jsonl')`
    - `append(obs: Observation): void` — Uses `appendFileSync` with `{ flag: 'a' }`. Creates `.careagent/` directory with `mkdirSync({ recursive: true })` if needed. Serializes observation as single JSON line + `\n`.
    - `query(filter?: { category?: ObservationCategory; field_path?: string }): Observation[]` — Reads the JSONL file line-by-line, parses each line as JSON, applies optional filter by category and/or field_path. Returns empty array if file does not exist.
    - `clear(): void` — Removes the observations file (for testing). Uses `rmSync` with `{ force: true }`.
    - Use only `node:fs` and `node:path` imports. Zero external dependencies.

    Create `src/refinement/proposal-queue.ts`:
    - `ProposalQueue` class constructor takes `workspacePath: string`
    - Queue path: `join(workspacePath, '.careagent', 'proposals.json')`
    - Internal shape: `{ proposals: Proposal[], last_updated: string }`
    - `load(): void` — Reads proposals.json if exists, otherwise initializes empty. Called in constructor.
    - `save(): void` — Writes proposals.json with `JSON.stringify(store, null, 2)`. Creates `.careagent/` directory if needed.
    - `add(proposal: Proposal): void` — Pushes proposal to array, calls save().
    - `getByStatus(status: Proposal['status']): Proposal[]` — Filter proposals by status.
    - `getPending(): Proposal[]` — Returns proposals with status `'pending'` or `'deferred'`.
    - `resolve(proposalId: string, resolution: ProposalResolution): Proposal` — Finds proposal by id, updates status to the resolution value, sets `resolved_at` to current ISO timestamp. If resolution is `'rejected'`, increments `rejection_count` (default 0). Calls save(). Throws if proposal not found.
    - `getById(id: string): Proposal | undefined` — Find by id.
    - Use `node:crypto.randomUUID()` for proposal ID generation in the generator (not here — queue just stores).

    Create unit tests in `test/unit/refinement/observation-store.test.ts`:
    - Test append writes JSONL format with newline separator
    - Test query reads back observations correctly
    - Test query with filter by category
    - Test query with filter by field_path
    - Test query returns empty array when file does not exist
    - Test clear removes the file
    - Test directory is created automatically on first append
    - Use `mkdtempSync` for temp workspace (established pattern)
  </action>
  <verify>
    Run `npx vitest run test/unit/refinement/observation-store.test.ts` — all tests pass.
    Run `npx vitest run test/unit/refinement/ --reporter=verbose` — all observation-store tests pass.
    Verify `src/refinement/types.ts` exports all expected types and constants.
  </verify>
  <done>
    ObservationStore appends observations as JSONL, queries with optional filters, and handles missing files gracefully. ProposalQueue persists proposals to JSON, supports add/resolve/query operations. All types are defined with SACROSANCT_FIELDS safety set.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create pattern matcher and proposal generator with scope field protection</name>
  <files>
    src/refinement/pattern-matcher.ts
    src/refinement/proposal-generator.ts
    test/unit/refinement/pattern-matcher.test.ts
    test/unit/refinement/proposal-generator.test.ts
  </files>
  <action>
    Create `src/refinement/pattern-matcher.ts`:
    - Export `detectDivergences(observations: Observation[], existingProposals: Proposal[], threshold?: number): DivergencePattern[]`
    - Default threshold: `DEFAULT_DIVERGENCE_THRESHOLD` (5)
    - Algorithm:
      1. Group observations by `field_path`
      2. For each group, count observations where `declared_value !== observed_value` (use JSON.stringify for deep comparison since values may be objects)
      3. Filter to groups with divergence count >= threshold
      4. **CRITICAL safety check:** Call `isScopeField(fieldPath)` on each group — skip any scope field group entirely. This is defense layer 1.
      5. Exclude field_paths that already have a pending or deferred proposal in `existingProposals`
      6. For rejected proposals: only allow if observation count >= `RESURFACE_THRESHOLD` (10) AND observation_count > the count when last rejected (tracked via rejection_count on existing proposal). This implements the "resurface after higher threshold" requirement.
      7. For each surviving group, determine `most_common_observed` value (mode of observed_value)
      8. Generate `evidence_summary` string: e.g., "{count} of your last {total} {category} events showed {observed} instead of your declared {declared}" — this must be human-readable per locked decision
    - Return array of `DivergencePattern` objects sorted by observation_count descending

    Create `src/refinement/proposal-generator.ts`:
    - Export `generateProposals(divergences: DivergencePattern[], sessionId: string): Proposal[]`
    - For each DivergencePattern, create a Proposal:
      - `id`: `crypto.randomUUID()`
      - `created_at`: `new Date().toISOString()`
      - `field_path`: from divergence
      - `category`: from divergence
      - `current_value`: `divergence.declared_value`
      - `proposed_value`: `divergence.most_common_observed`
      - `evidence_summary`: from divergence
      - `observation_count`: from divergence
      - `status`: `'pending'`
      - `rejection_count`: 0
    - **CRITICAL safety check (defense layer 2):** Assert `!isScopeField(proposal.field_path)` for each generated proposal. Throw Error if scope field leaks through — this should never happen if pattern-matcher is correct, but defense in depth per research.
    - Export `generateDiffView(proposal: Proposal): string` — returns a simple field-level diff:
      ```
      --- CANS.md (current)
      +++ CANS.md (proposed)
      @@ {field_path} @@
      - {formatValue(current_value)}
      + {formatValue(proposed_value)}
      ```
      Where `formatValue` uses `JSON.stringify` for objects or direct string conversion for primitives.

    Create unit tests in `test/unit/refinement/pattern-matcher.test.ts`:
    - Test: 5 observations of same field divergence produces a DivergencePattern
    - Test: 4 observations (below threshold) produces nothing
    - Test: Scope field observations (scope.permitted_actions) are NEVER included regardless of count
    - Test: Custom threshold (e.g., 3) works
    - Test: Field with existing pending proposal is excluded
    - Test: Field with existing deferred proposal is excluded
    - Test: Rejected proposal resurfacing only when observation_count >= RESURFACE_THRESHOLD
    - Test: evidence_summary is human-readable
    - Test: Multiple fields with divergences sorted by count descending

    Create unit tests in `test/unit/refinement/proposal-generator.test.ts`:
    - Test: Creates proposal from DivergencePattern
    - Test: Proposal has UUID id, pending status, rejection_count 0
    - Test: generateDiffView produces correct format
    - Test: Throws if scope field somehow leaks into divergences (defense layer 2)
    - Test: Multiple divergences produce multiple proposals
  </action>
  <verify>
    Run `npx vitest run test/unit/refinement/pattern-matcher.test.ts` — all tests pass.
    Run `npx vitest run test/unit/refinement/proposal-generator.test.ts` — all tests pass.
    Run `npx vitest run test/unit/refinement/` — all refinement unit tests pass.
    Verify scope protection: grep for `isScopeField` in both pattern-matcher.ts and proposal-generator.ts — must appear in both files (defense in depth).
  </verify>
  <done>
    Pattern matcher detects divergences at 5+ threshold, hard-excludes scope fields, respects existing proposal states, and supports rejected proposal resurfacing at higher thresholds. Proposal generator creates Proposals with evidence summaries and diff views, with a defensive scope field assertion.
  </done>
</task>

</tasks>

<verification>
- `npx vitest run test/unit/refinement/` — all unit tests pass
- `isScopeField` function exists in types.ts and is called in both pattern-matcher.ts and proposal-generator.ts
- `SACROSANCT_FIELDS` Set includes all scope.* paths
- ObservationStore reads/writes JSONL at .careagent/observations.jsonl
- ProposalQueue reads/writes JSON at .careagent/proposals.json
- All types are exported from their respective modules
</verification>

<success_criteria>
- Observation store appends and queries JSONL observations
- Pattern matcher detects 5+ divergence patterns while excluding scope fields
- Proposal generator creates proposals with evidence summaries and diff views
- Proposal queue persists proposals with lifecycle management
- All unit tests pass with zero failures
- Scope protection is verified at two independent layers
</success_criteria>

<output>
After completion, create `.planning/phases/05-cans-continuous-improvement-and-integration/05-01-SUMMARY.md`
</output>
