---
phase: 07-production-wiring-gap-closure
plan: 02
type: execute
wave: 2
depends_on:
  - 07-01
files_modified:
  - src/cli/status-command.ts
  - test/integration/production-wiring.test.ts
autonomous: true
requirements:
  - ONBD-04
  - CANS-08
  - SKIL-05
  - SKIL-06
  - PORT-02

must_haves:
  truths:
    - "careagent status displays loaded clinical skills from the skill cache file"
    - "careagent status shows 'Not loaded in this session' when no cache exists"
    - "Integration tests confirm detectPlatform, buildChartSkillInstructions, refinement.observe, and skill cache write are all reachable from production call paths"
    - "All 697+ existing tests continue passing"
  artifacts:
    - path: "src/cli/status-command.ts"
      provides: "Skill display section in formatStatus() using readSkillCache() helper"
      contains: "readSkillCache"
    - path: "test/integration/production-wiring.test.ts"
      provides: "Integration tests for all five production wiring gaps"
      min_lines: 80
  key_links:
    - from: "src/cli/status-command.ts"
      to: ".careagent/skill-load-results.json"
      via: "readSkillCache() reads the cache file written by entry points"
      pattern: "skill-load-results\\.json"
    - from: "test/integration/production-wiring.test.ts"
      to: "src/entry/standalone.ts"
      via: "activate() called with a temp workspace — confirms all wires fire"
      pattern: "activate\\("
---

<objective>
Complete ONBD-04 by adding skill display to formatStatus(), then add integration tests that confirm all five production wiring gaps are closed.

Purpose: Plan 01 added the wiring but did not touch the status command or add tests. This plan closes the loop: formatStatus() now reads the skill cache and displays loaded skills, and a focused integration test file verifies each wire fires during a real activate() call.

Output: Updated src/cli/status-command.ts with skill display; new test/integration/production-wiring.test.ts with 5 integration tests.
</objective>

<execution_context>
@/Users/medomatic/.claude/get-shit-done/workflows/execute-plan.md
@/Users/medomatic/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-production-wiring-gap-closure/07-RESEARCH.md
@.planning/phases/07-production-wiring-gap-closure/07-01-SUMMARY.md

Key source files (read before modifying):
@src/cli/status-command.ts
@src/entry/standalone.ts
@test/integration/e2e-flow.test.ts
@test/unit/cli/status-command.test.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add skill display to formatStatus() (ONBD-04 read side)</name>
  <files>src/cli/status-command.ts</files>
  <action>
    Add a `readSkillCache()` helper and a "Clinical Skills" display section to `formatStatus()`. The function signature must NOT change — it must remain `formatStatus(workspacePath: string): string`.

    **Before writing:** Read the current `src/cli/status-command.ts` in full to understand the existing structure and where to insert the new section.

    **Add `readSkillCache()` helper function** (above `formatStatus()`):

    ```typescript
    interface SkillCacheEntry {
      skillId: string;
      loaded: boolean;
      version?: string;
      reason?: string;
    }

    interface SkillCache {
      timestamp: string;
      results: SkillCacheEntry[];
    }

    function readSkillCache(workspacePath: string): SkillCacheEntry[] {
      const cachePath = join(workspacePath, '.careagent', 'skill-load-results.json');
      if (!existsSync(cachePath)) return [];
      try {
        const data = JSON.parse(readFileSync(cachePath, 'utf-8')) as SkillCache;
        return Array.isArray(data.results) ? data.results : [];
      } catch {
        return [];
      }
    }
    ```

    Note: `existsSync`, `readFileSync`, and `join` are already imported. No new imports needed.

    **Update `formatStatus()`** to call `readSkillCache()` and render results:

    1. At the top of `formatStatus()` alongside the other data reads, add:
       ```typescript
       const skillCache = readSkillCache(workspacePath);
       ```

    2. Find the section that renders "Hardening: always on (deterministic)" inside the `if (result.active && result.document)` block. AFTER that line, add:
       ```typescript
       lines.push('');
       lines.push('Clinical Skills:');
       if (skillCache.length === 0) {
         lines.push('  Not loaded in this session');
       } else {
         for (const entry of skillCache) {
           const status = entry.loaded ? 'Loaded' : `Not Loaded — ${entry.reason ?? 'unknown'}`;
           const version = entry.version ? ` (${entry.version})` : '';
           lines.push(`  ${entry.skillId}${version}:`.padEnd(22) + status);
         }
       }
       ```

    3. ALSO add a "Clinical Skills" section in the inactive state path — when `result.active` is false, show skill cache if it exists (a provider may check status without the plugin running):
       After the `if (!result.active && result.reason)` block (the `Reason:` line), add:
       ```typescript
       if (skillCache.length > 0) {
         lines.push('');
         lines.push('Clinical Skills (last session):');
         for (const entry of skillCache) {
           const status = entry.loaded ? 'Loaded' : `Not Loaded — ${entry.reason ?? 'unknown'}`;
           const version = entry.version ? ` (${entry.version})` : '';
           lines.push(`  ${entry.skillId}${version}:`.padEnd(22) + status);
         }
       }
       ```

    IMPORTANT: Do not change the function signature, the output for any existing test cases, or the order of the "Audit Stats" and "Integrity" sections. The new "Clinical Skills" section is inserted before "Audit Stats" in the active state, and optionally after "Reason:" in inactive state.

    Verify: read the existing test file `test/unit/cli/status-command.test.ts` to understand what output strings tests assert on, and make sure the new lines do not conflict. The new lines are additive — no existing lines are removed or reworded.
  </action>
  <verify>
    1. `npx tsc --noEmit` — zero errors
    2. `npx vitest run test/unit/cli/status-command.test.ts --reporter=verbose` — all existing status tests pass
    3. Manual check: write a temp skill cache JSON to a temp dir, call `formatStatus(tempDir)`, confirm "Clinical Skills" section appears with the correct entries
  </verify>
  <done>
    formatStatus() renders a "Clinical Skills" section using the skill cache. When cache is absent, it shows "Not loaded in this session". Existing status command tests all still pass. TypeScript compiles clean.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add integration tests for all five production wiring gaps</name>
  <files>test/integration/production-wiring.test.ts</files>
  <action>
    Create a new integration test file that uses `activate()` from `src/entry/standalone.ts` with a temporary workspace to verify each of the five wiring gaps is live. The tests use vitest and follow the same patterns as `test/integration/e2e-flow.test.ts`.

    **Before writing:** Read `test/integration/e2e-flow.test.ts` to understand:
    - How the temp workspace is set up (mkdtemp, writing CANS.md)
    - How `activate()` is imported and called
    - How to assert on skill results, refinement engine, and audit log

    Also read `test/unit/adapters/detect.test.ts` to understand how detectPlatform is tested and what inputs produce what outputs.

    **Create `test/integration/production-wiring.test.ts`** with the following test suite:

    ```typescript
    /**
     * Integration tests for Phase 7 production wiring gap closure.
     *
     * Verifies that all five orphaned subsystem functions are reachable
     * from their production call sites after the wiring changes.
     */
    import { describe, it, expect, beforeEach, afterEach } from 'vitest';
    import { mkdtempSync, writeFileSync, mkdirSync, existsSync, readFileSync } from 'node:fs';
    import { tmpdir } from 'node:os';
    import { join } from 'node:path';
    import { rmSync } from 'node:fs';
    import { detectPlatform } from '../../src/adapters/detect.js';
    import { activate } from '../../src/entry/standalone.js';

    // Minimal valid CANS.md content — copy the fixture pattern from e2e-flow.test.ts
    // (read that file and use the same fixture or import it if exported)
    ```

    Include these five test cases:

    **Test 1 — PORT-02: detectPlatform is callable and classifies inputs correctly:**
    ```typescript
    describe('PORT-02: detectPlatform production call site', () => {
      it('returns "openclaw" for an api object with openclaw-shaped methods', () => {
        const mockApi = { registerCli: () => {}, on: () => {}, workspaceDir: '/tmp' };
        expect(detectPlatform(mockApi)).toBe('openclaw');
      });

      it('returns "standalone" for undefined or plain object', () => {
        expect(detectPlatform(undefined)).toBe('standalone');
        expect(detectPlatform({})).toBe('standalone');
      });
    });
    ```

    **Test 2 — SKIL-05/06: buildChartSkillInstructions is called when chart-skill loads:**
    After activate() with a valid CANS.md + a skills directory containing a mock chart-skill manifest:
    - Assert that `skills` returned from `activate()` contains an entry with `skillId: 'chart-skill'` and `loaded: true` OR that the skill cache file contains chart-skill.
    - If the real skills directory does not include a loadable chart-skill in the test environment (integrity checks may block it), assert that `buildChartSkillInstructions()` can be called independently and returns a non-empty string:
    ```typescript
    import { buildChartSkillInstructions } from '../../src/skills/chart-skill/index.js';
    it('buildChartSkillInstructions returns non-empty instructions', () => {
      const instructions = buildChartSkillInstructions();
      expect(typeof instructions).toBe('string');
      expect(instructions.length).toBeGreaterThan(0);
    });
    it('buildChartSkillInstructions with voice returns voice-specific content', () => {
      const voice = { chart: 'concise, precise', order: '', charge: '', perform: '', interpret: '', educate: '', coordinate: '' };
      const instructions = buildChartSkillInstructions(voice as any);
      expect(instructions).toContain('concise, precise');
    });
    ```

    **Test 3 — CANS-08: refinement.observe() is callable from the engine returned by activate():**
    ```typescript
    it('refinement engine returned by activate() accepts observe() calls', () => {
      const { refinement } = activate(tempWorkspace);
      expect(refinement).toBeDefined();
      // Should not throw — observe() is the production call site
      expect(() => {
        refinement!.observe({
          category: 'skill_usage',
          field_path: 'skills.chart',
          declared_value: 'chart-skill',
          observed_value: 'session_start',
        });
      }).not.toThrow();
    });
    ```

    **Test 4 — ONBD-04 cache write: skill-load-results.json is written after activate():**
    ```typescript
    it('activate() writes skill-load-results.json to .careagent/', () => {
      activate(tempWorkspace);
      const cachePath = join(tempWorkspace, '.careagent', 'skill-load-results.json');
      expect(existsSync(cachePath)).toBe(true);
      const cache = JSON.parse(readFileSync(cachePath, 'utf-8'));
      expect(cache).toHaveProperty('timestamp');
      expect(Array.isArray(cache.results)).toBe(true);
    });
    ```

    **Test 5 — ONBD-04 status read: formatStatus() shows Clinical Skills section:**
    ```typescript
    import { formatStatus } from '../../src/cli/status-command.js';
    it('formatStatus() shows "Clinical Skills" section', () => {
      // Write a minimal skill cache
      const cacheDir = join(tempWorkspace, '.careagent');
      mkdirSync(cacheDir, { recursive: true });
      writeFileSync(
        join(cacheDir, 'skill-load-results.json'),
        JSON.stringify({
          timestamp: new Date().toISOString(),
          results: [{ skillId: 'chart-skill', loaded: true, version: '1.0.0' }],
        }),
        'utf-8',
      );
      const output = formatStatus(tempWorkspace);
      expect(output).toContain('Clinical Skills');
      expect(output).toContain('chart-skill');
      expect(output).toContain('Loaded');
    });

    it('formatStatus() shows "Not loaded in this session" when no cache exists', () => {
      const emptyWorkspace = mkdtempSync(join(tmpdir(), 'careagent-test-empty-'));
      try {
        const output = formatStatus(emptyWorkspace);
        // When inactive with no CANS.md, skills section may not appear — just confirm no crash
        expect(typeof output).toBe('string');
      } finally {
        rmSync(emptyWorkspace, { recursive: true, force: true });
      }
    });
    ```

    **Workspace setup:** Use `beforeEach` / `afterEach` with `mkdtempSync` and `rmSync` for temp workspace lifecycle. Copy the valid CANS.md fixture from `e2e-flow.test.ts` (or read that file to find the fixture path and replicate it).

    **Pitfall mitigation:** If `activate()` fails because the temp workspace has no CANS.md, the `activation.active` will be false — which is fine for cache/status tests. For the refinement observer test, you need `activation.active === true`, which requires a valid CANS.md in the temp workspace. Read `e2e-flow.test.ts` to see exactly what CANS.md content makes activation succeed and replicate it.
  </action>
  <verify>
    1. `npx tsc --noEmit` — zero errors
    2. `npx vitest run test/integration/production-wiring.test.ts --reporter=verbose` — all tests in the new file pass
    3. `npx vitest run --reporter=verbose` — full suite 697+ tests pass, 0 failing (no regressions)
  </verify>
  <done>
    test/integration/production-wiring.test.ts exists with at least 7 passing tests covering all five requirements (PORT-02, SKIL-05, SKIL-06, CANS-08, ONBD-04). Full suite passes with no regressions.
  </done>
</task>

</tasks>

<verification>
Final phase verification:
1. `npx tsc --noEmit` — zero TypeScript errors across all modified files
2. `npx vitest run --reporter=verbose` — all tests pass (697+ original + new integration tests), 0 failing
3. Five requirement checks:
   - CANS-08: `grep -rn "refinement.observe" src/entry/` shows call sites in both entry files
   - SKIL-05/06: `grep -rn "buildChartSkillInstructions" src/entry/` shows call sites in both entry files
   - PORT-02: `grep -rn "detectPlatform" src/entry/` shows call sites in both entry files
   - ONBD-04 write: `grep -rn "skill-load-results.json" src/entry/` shows write in both entry files
   - ONBD-04 read: `grep -n "readSkillCache\|Clinical Skills" src/cli/status-command.ts` shows display logic
4. Status output check: running the new integration tests confirms the "Clinical Skills" section appears in formatStatus() output
</verification>

<success_criteria>
- ONBD-04 fully closed: formatStatus() displays loaded clinical skills from cache; "Not loaded in this session" shown when cache absent
- Integration test file covers all five requirements with passing tests
- Zero regressions in the 697+ existing test suite
- TypeScript compiles clean across all modified files
- Phase 7 all five requirements (CANS-08, SKIL-05, SKIL-06, PORT-02, ONBD-04) have both production call sites and test coverage
</success_criteria>

<output>
After completion, create `.planning/phases/07-production-wiring-gap-closure/07-02-SUMMARY.md`
</output>
