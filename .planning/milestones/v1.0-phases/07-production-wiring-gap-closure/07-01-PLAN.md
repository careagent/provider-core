---
phase: 07-production-wiring-gap-closure
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/entry/openclaw.ts
  - src/entry/standalone.ts
autonomous: true
requirements:
  - PORT-02
  - SKIL-05
  - SKIL-06
  - CANS-08
  - ONBD-04

must_haves:
  truths:
    - "detectPlatform(api) is called in both entry points before the adapter creation completes"
    - "buildChartSkillInstructions() is called when chart-skill loads and the output is injected via onAgentBootstrap"
    - "refinement.observe() is called via onAgentBootstrap on every clinical session start"
    - "skill-load-results.json is written to .careagent/ after every loadClinicalSkills() call in both entry points"
  artifacts:
    - path: "src/entry/openclaw.ts"
      provides: "All four production wiring points for openclaw platform"
      contains: "detectPlatform"
    - path: "src/entry/standalone.ts"
      provides: "All four production wiring points for standalone platform"
      contains: "detectPlatform"
  key_links:
    - from: "src/entry/openclaw.ts"
      to: "src/adapters/detect.ts"
      via: "detectPlatform(api) import and call at top of register()"
      pattern: "detectPlatform\\(api\\)"
    - from: "src/entry/openclaw.ts"
      to: "src/skills/chart-skill/index.ts"
      via: "buildChartSkillInstructions(cans.voice) in onAgentBootstrap handler"
      pattern: "buildChartSkillInstructions"
    - from: "src/entry/openclaw.ts"
      to: "src/refinement/refinement-engine.ts"
      via: "refinement.observe() in onAgentBootstrap handler"
      pattern: "refinement\\.observe"
    - from: "src/entry/openclaw.ts"
      to: ".careagent/skill-load-results.json"
      via: "writeFileSync after loadClinicalSkills()"
      pattern: "skill-load-results\\.json"
---

<objective>
Wire four previously orphaned subsystem functions to their production call sites in both entry points, closing PORT-02, SKIL-05, SKIL-06, CANS-08, and the cache-write half of ONBD-04.

Purpose: All five subsystems (detectPlatform, buildChartSkillInstructions, refinement.observe, skill cache) are fully implemented and unit-tested but have zero production callers. This plan adds the minimal, targeted wiring that makes each live without touching subsystem logic.

Output: Modified src/entry/openclaw.ts and src/entry/standalone.ts with all four wiring points active. No new files — only additions to existing files.
</objective>

<execution_context>
@/Users/medomatic/.claude/get-shit-done/workflows/execute-plan.md
@/Users/medomatic/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-production-wiring-gap-closure/07-RESEARCH.md

Key source files (read before modifying):
@src/entry/openclaw.ts
@src/entry/standalone.ts
@src/adapters/detect.ts
@src/skills/chart-skill/index.ts
@src/refinement/types.ts
@src/adapters/openclaw/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire detectPlatform() in both entry points (PORT-02)</name>
  <files>src/entry/openclaw.ts, src/entry/standalone.ts</files>
  <action>
    Add `detectPlatform` import and call to both entry points so PORT-02 (platform auto-detection via duck-typing) has a production call site.

    In `src/entry/openclaw.ts`:
    1. Add import at top of file: `import { detectPlatform } from '../adapters/detect.js';`
    2. Insert as the FIRST line of the `register(api)` function body, BEFORE `const adapter = createAdapter(api)`:
       ```typescript
       const platform = detectPlatform(api);
       ```
    3. On the line that creates the adapter add a log call after createAdapter to surface the detection:
       ```typescript
       const adapter = createAdapter(api);
       adapter.log('info', `[CareAgent] Platform detected: ${platform}`);
       ```
       (Note: `adapter.log` is available after createAdapter; the platform const must be assigned before createAdapter)

    In `src/entry/standalone.ts`:
    1. Add import at top: `import { detectPlatform } from '../adapters/detect.js';`
    2. Insert as the FIRST line of `activate(workspacePath?)` body:
       ```typescript
       const platform = detectPlatform(undefined);
       ```
       (standalone receives no api object — pass undefined; detectPlatform returns 'standalone' for undefined input)
    3. After `const adapter = createStandaloneAdapter(workspacePath)` add:
       ```typescript
       adapter.log('info', `[CareAgent] Platform detected: ${platform}`);
       ```

    IMPORTANT: Do NOT try to make detectPlatform switch adapters. The spirit of PORT-02 is that detectPlatform is called and the result is observable. Each entry point has its own fixed adapter — detectPlatform documents the detected platform at startup.

    Before writing, read `src/adapters/detect.ts` to confirm the exact function signature and what it returns for `undefined` input. If it does not handle undefined gracefully, pass a plain empty object `{}` instead.
  </action>
  <verify>Run `npx tsc --noEmit` from project root — must compile with zero errors.</verify>
  <done>Both entry files import detectPlatform and call it; TypeScript compiles cleanly; existing tests still pass (`npx vitest run --reporter=verbose` shows 697+ passing, 0 failing).</done>
</task>

<task type="auto">
  <name>Task 2: Wire bootstrap handlers for chart-skill injection and refinement observation (SKIL-05, SKIL-06, CANS-08)</name>
  <files>src/entry/openclaw.ts, src/entry/standalone.ts</files>
  <action>
    Add two `onAgentBootstrap` registrations in `openclaw.ts` after the existing skill loading block (Step 6.5) and after the refinement engine creation (Step 6.7). Mirror the pattern in `standalone.ts`.

    **Before writing:** Read `src/adapters/openclaw/index.ts` to confirm that `onAgentBootstrap` delegates to `raw.on('agent:bootstrap', handler)`. The handler registration passes through to the host platform's event emitter — multiple calls to `raw.on` with the same event name are queued by the host (not overwritten by the adapter). This means separate `onAgentBootstrap` calls are safe in openclaw mode.

    Also read `src/refinement/types.ts` to confirm valid ObservationCategory values. Valid values as of research: `'voice' | 'autonomy' | 'credential' | 'skill_usage' | 'identity'`. Use `'skill_usage'` category for the session-start observation.

    **In `src/entry/openclaw.ts`:**

    1. Add imports at top of file:
       ```typescript
       import { CHART_SKILL_ID, buildChartSkillInstructions } from '../skills/chart-skill/index.js';
       ```

    2. Inside the skill loading `try` block in Step 6.5, AFTER the `loadedSkills` and `blockedSkills` log calls, add chart-skill bootstrap registration:
       ```typescript
       // SKIL-05, SKIL-06: Inject chart-skill instructions into agent context if loaded
       const chartSkillLoaded = loadedSkills.some(s => s.skillId === CHART_SKILL_ID);
       if (chartSkillLoaded) {
         const instructions = buildChartSkillInstructions(cans.voice);
         adapter.onAgentBootstrap((context) => {
           context.addFile('CHART_SKILL_INSTRUCTIONS', instructions);
         });
         adapter.log('info', '[CareAgent] Chart-skill instructions registered for agent bootstrap');
       }
       ```
       Note: `cans.voice` may be undefined — pass it directly; `buildChartSkillInstructions(voice?: Voice)` handles undefined gracefully.

    3. After Step 6.7 refinement engine creation (after `adapter.registerCliCommand` for proposals), add observation bootstrap handler:
       ```typescript
       // CANS-08: Feed session-start observation into refinement engine on agent bootstrap
       adapter.onAgentBootstrap((_context) => {
         refinement.observe({
           category: 'skill_usage',
           field_path: 'skills.chart',
           declared_value: 'chart-skill',
           observed_value: 'session_start',
         });
       });
       ```

    **In `src/entry/standalone.ts`:**

    1. Add imports:
       ```typescript
       import { CHART_SKILL_ID, buildChartSkillInstructions } from '../skills/chart-skill/index.js';
       ```

    2. After the `skills = loadClinicalSkills(...)` call inside the `try` block, add chart-skill bootstrap registration:
       ```typescript
       // SKIL-05, SKIL-06: Inject chart-skill instructions if loaded
       const loadedSkills = skills.filter(s => s.loaded);
       const chartSkillLoaded = loadedSkills.some(s => s.skillId === CHART_SKILL_ID);
       if (chartSkillLoaded) {
         const instructions = buildChartSkillInstructions(activation.document!.voice);
         adapter.onAgentBootstrap((context) => {
           context.addFile('CHART_SKILL_INSTRUCTIONS', instructions);
         });
       }
       ```
       Note: standalone adapter's `onAgentBootstrap` is a no-op — this is safe.

    3. After the `refinement` creation (after `createRefinementEngine`), add observation registration:
       ```typescript
       // CANS-08: Feed session-start observation via bootstrap handler
       adapter.onAgentBootstrap((_context) => {
         refinement.observe({
           category: 'skill_usage',
           field_path: 'skills.chart',
           declared_value: 'chart-skill',
           observed_value: 'session_start',
         });
       });
       ```

    IMPORTANT: Check if `cans.voice` / `activation.document!.voice` is a valid field on the CANSDocument type by reading the type definition. If the `voice` field is at a different path (e.g., `cans.voice` does not exist and it's nested differently), use `undefined` as the fallback — `buildChartSkillInstructions(undefined)` returns generic instructions and is fully valid.
  </action>
  <verify>
    1. `npx tsc --noEmit` — zero errors
    2. `npx vitest run --reporter=verbose` — 697+ passing, 0 failing
    3. Grep confirms wiring: `grep -n "buildChartSkillInstructions\|refinement.observe\|CHART_SKILL_ID" src/entry/openclaw.ts src/entry/standalone.ts`
  </verify>
  <done>
    Both entry files call buildChartSkillInstructions and refinement.observe via bootstrap handlers after their respective skill loading and refinement engine creation blocks. TypeScript compiles clean. All existing tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 3: Write skill cache file from entry points (ONBD-04 write side)</name>
  <files>src/entry/openclaw.ts, src/entry/standalone.ts</files>
  <action>
    Persist skill load results to `.careagent/skill-load-results.json` after every `loadClinicalSkills()` call so `formatStatus()` can read them without requiring a live plugin boot.

    **In `src/entry/openclaw.ts`:**

    1. Add built-in imports at the top (with other node: imports):
       ```typescript
       import { mkdirSync, writeFileSync } from 'node:fs';
       ```

    2. Inside Step 6.5 skill loading `try` block, AFTER the `loadedSkills`/`blockedSkills` log calls and AFTER the chart-skill bootstrap block from Task 2, add:
       ```typescript
       // ONBD-04: Persist skill results so careagent status can display loaded skills
       try {
         const cacheDir = join(workspacePath, '.careagent');
         mkdirSync(cacheDir, { recursive: true });
         writeFileSync(
           join(cacheDir, 'skill-load-results.json'),
           JSON.stringify(
             {
               timestamp: new Date().toISOString(),
               results: skillResults.map(r => ({
                 skillId: r.skillId,
                 loaded: r.loaded,
                 version: r.version,
                 reason: r.reason,
               })),
             },
             null,
             2,
           ),
           'utf-8',
         );
       } catch (cacheErr) {
         const msg = cacheErr instanceof Error ? cacheErr.message : String(cacheErr);
         adapter.log('warn', `[CareAgent] Failed to write skill cache: ${msg}`);
       }
       ```
       Note: This is inside the existing skill loading `try/catch` block's `try` body, but wrapped in its own inner try/catch so a cache write failure does NOT abort skill loading.

    **In `src/entry/standalone.ts`:**

    1. Add built-in imports:
       ```typescript
       import { mkdirSync, writeFileSync } from 'node:fs';
       ```

    2. After `skills = loadClinicalSkills(...)` inside the `try` block (after Task 2's chart-skill block), add:
       ```typescript
       // ONBD-04: Persist skill results for status command
       try {
         const cacheDir = join(resolvedPath, '.careagent');
         mkdirSync(cacheDir, { recursive: true });
         writeFileSync(
           join(cacheDir, 'skill-load-results.json'),
           JSON.stringify(
             {
               timestamp: new Date().toISOString(),
               results: skills.map(r => ({
                 skillId: r.skillId,
                 loaded: r.loaded,
                 version: r.version,
                 reason: r.reason,
               })),
             },
             null,
             2,
           ),
           'utf-8',
         );
       } catch {
         // Non-fatal: status will show "Not loaded in this session"
       }
       ```

    Note: `join` is already imported in both files. `mkdirSync` and `writeFileSync` are new imports — add them to the existing `node:fs` or `node:path` import groups. If `node:fs` is not yet imported in `openclaw.ts`, add the import. Check current imports before adding to avoid duplicates.
  </action>
  <verify>
    1. `npx tsc --noEmit` — zero errors
    2. `npx vitest run --reporter=verbose` — 697+ passing, 0 failing
    3. Check import lines: `grep -n "mkdirSync\|writeFileSync\|skill-load-results" src/entry/openclaw.ts src/entry/standalone.ts`
  </verify>
  <done>
    Both entry files write `.careagent/skill-load-results.json` after skill loading, using a nested try/catch so cache write failures are non-fatal. TypeScript compiles clean. All existing tests pass.
  </done>
</task>

</tasks>

<verification>
After all three tasks:
1. `npx tsc --noEmit` — zero TypeScript errors
2. `npx vitest run --reporter=verbose` — all 697+ tests pass, 0 failing
3. Five grep checks confirm wiring is live:
   - `grep -n "detectPlatform" src/entry/openclaw.ts src/entry/standalone.ts`
   - `grep -n "buildChartSkillInstructions" src/entry/openclaw.ts src/entry/standalone.ts`
   - `grep -n "refinement.observe" src/entry/openclaw.ts src/entry/standalone.ts`
   - `grep -n "skill-load-results.json" src/entry/openclaw.ts src/entry/standalone.ts`
   - `grep -n "CHART_SKILL_ID" src/entry/openclaw.ts src/entry/standalone.ts`
</verification>

<success_criteria>
- PORT-02: detectPlatform(api) called in both entry points, result logged
- SKIL-05/06: buildChartSkillInstructions() called when chart-skill loads; instructions registered via onAgentBootstrap in openclaw.ts
- CANS-08: refinement.observe() called via onAgentBootstrap in both entry points on session start
- ONBD-04 (write): .careagent/skill-load-results.json written after skill loading in both entry points
- Zero regressions in the 697+ existing test suite
</success_criteria>

<output>
After completion, create `.planning/phases/07-production-wiring-gap-closure/07-01-SUMMARY.md`
</output>
