---
phase: 03-runtime-hardening
plan: 03
type: tdd
wave: 2
depends_on: ["03-01", "03-02"]
files_modified:
  - src/hardening/engine.ts
  - src/hardening/canary.ts
  - src/hardening/index.ts
  - src/hardening/types.ts
  - test/unit/hardening/hardening.test.ts
  - test/unit/hardening/canary.test.ts
autonomous: true

must_haves:
  truths:
    - "Engine.activate() registers a before_tool_call handler via adapter.onBeforeToolCall()"
    - "Engine.activate() registers a bootstrap handler via adapter.onAgentBootstrap() that injects CANS protocol"
    - "Engine.check() runs layers 1-4 in sequence with short-circuit-on-deny"
    - "Engine.check() audit-logs every layer result (both allow and deny) via AuditPipeline"
    - "When any layer denies, subsequent layers are skipped and the deny result is returned"
    - "Engine.injectProtocol() returns the extracted protocol rules from CANS"
    - "Canary marks verified on first before_tool_call; warns provider after 30s timeout if hook never fires"
    - "Every hardening decision has a blocking_layer field in the audit entry when denied"
  artifacts:
    - path: "src/hardening/engine.ts"
      provides: "Real engine orchestrator replacing stub"
      exports: ["createHardeningEngine"]
    - path: "src/hardening/canary.ts"
      provides: "Hook liveness canary for HARD-07"
      exports: ["setupCanary"]
    - path: "src/hardening/index.ts"
      provides: "Updated re-exports including layers and canary"
    - path: "test/unit/hardening/hardening.test.ts"
      provides: "Engine orchestrator tests (replaces stub tests)"
    - path: "test/unit/hardening/canary.test.ts"
      provides: "Canary lifecycle tests"
  key_links:
    - from: "src/hardening/engine.ts"
      to: "src/hardening/layers/tool-policy.ts"
      via: "import { checkToolPolicy }"
      pattern: "checkToolPolicy"
    - from: "src/hardening/engine.ts"
      to: "src/hardening/layers/exec-allowlist.ts"
      via: "import { checkExecAllowlist }"
      pattern: "checkExecAllowlist"
    - from: "src/hardening/engine.ts"
      to: "src/audit/pipeline.ts"
      via: "audit.log() and audit.logBlocked()"
      pattern: "audit\\.log\\("
    - from: "src/hardening/engine.ts"
      to: "src/adapters/types.ts"
      via: "adapter.onBeforeToolCall() and adapter.onAgentBootstrap()"
      pattern: "adapter\\.onBeforeToolCall"
---

<objective>
Build the hardening engine orchestrator that composes all layers, integrates with the audit pipeline, manages the canary lifecycle, and wires into the adapter hooks.

Purpose: The engine is the single integration point (HARD-05, HARD-06, HARD-07). It composes the four layer functions from Plans 01 and 02, runs them with short-circuit-on-deny, audit-logs every decision, manages the before_tool_call canary, and registers hooks via the PlatformAdapter. This is the core of Phase 3.

Output: Real engine implementation replacing the stub, canary module, updated index.ts exports, comprehensive tests replacing the 7 stub tests.
</objective>

<execution_context>
@/Users/thomasanderson/.claude/get-shit-done/workflows/execute-plan.md
@/Users/thomasanderson/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-runtime-hardening/03-01-SUMMARY.md
@.planning/phases/03-runtime-hardening/03-02-SUMMARY.md
@src/hardening/types.ts
@src/hardening/engine.ts
@src/hardening/index.ts
@src/adapters/types.ts
@src/audit/pipeline.ts
@src/activation/cans-schema.ts
@test/fixtures/valid-cans-data.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement engine orchestrator with TDD</name>
  <files>
    src/hardening/engine.ts
    src/hardening/index.ts
    src/hardening/types.ts
    test/unit/hardening/hardening.test.ts
  </files>
  <action>
**Step 1: RED — Replace stub tests with engine implementation tests**

Completely rewrite `test/unit/hardening/hardening.test.ts` (delete old stub tests):

Create mock helpers:
- `createMockAdapter()`: Returns a mock PlatformAdapter that records onBeforeToolCall and onAgentBootstrap handler registrations. Store registered handlers for later invocation in tests.
- `createMockAudit()`: Returns a mock with `log()`, `logBlocked()`, `createTraceId()` that record all calls. Use `vi.fn()` for each method.
- `makeCans(overrides?)`: Deep-merge into validCANSData fixture.

Test cases for `createHardeningEngine()`:
1. `activate()` registers a before_tool_call handler via adapter.onBeforeToolCall
2. `activate()` registers a bootstrap handler via adapter.onAgentBootstrap
3. `check()` before activate() throws "Engine not activated"
4. `check()` with a tool in permitted_actions returns `{ allowed: true }`
5. `check()` with a tool in prohibited_actions returns `{ allowed: false }` with blocking_layer
6. `check()` with a non-allowlisted exec command returns `{ allowed: false }`
7. `check()` short-circuits: if Layer 1 denies, Layer 2/3/4 are not evaluated (verify audit log has only 1 entry, not 4)
8. `check()` when all layers allow: audit log has 4 entries (one per layer) all with outcome 'allowed'
9. `check()` deny writes blocking_layer and blocked_reason to audit
10. `check()` allow writes layer name to audit details
11. `injectProtocol()` returns array of strings (protocol rule lines)
12. Bootstrap handler calls injectProtocol and passes content to context.addFile
13. before_tool_call handler calls engine.check() and returns { block: true, blockReason } on deny
14. before_tool_call handler returns { block: false } on allow

Run tests: all MUST FAIL (RED).

**Step 2: GREEN — Implement engine**

Replace `src/hardening/engine.ts` entirely:

```typescript
import type { ToolCallEvent, ToolCallResult } from '../adapters/types.js';
import type { HardeningEngine, HardeningConfig, HardeningLayerResult, HardeningLayerFn } from './types.js';
import type { CANSDocument } from '../activation/cans-schema.js';
import type { AuditPipeline } from '../audit/pipeline.js';
import type { PlatformAdapter } from '../adapters/types.js';
import { checkToolPolicy } from './layers/tool-policy.js';
import { checkExecAllowlist } from './layers/exec-allowlist.js';
import { checkCansInjection } from './layers/cans-injection.js';
import { checkDockerSandbox } from './layers/docker-sandbox.js';
import { injectProtocol, extractProtocolRules } from './layers/cans-injection.js';
import { setupCanary } from './canary.js';
```

Engine implementation:
- Private state: `activated: boolean`, `cans: CANSDocument`, `audit: AuditPipeline`, `adapter: PlatformAdapter`
- `layers` array: `[checkToolPolicy, checkExecAllowlist, checkCansInjection, checkDockerSandbox]`
- `activate(config)`: Store config, set activated flag, register hooks, set up canary
  - `adapter.onBeforeToolCall((event) => { ... calls check(), marks canary, returns ToolCallResult })`
  - `adapter.onAgentBootstrap((context) => { if cans.hardening.cans_protocol_injection, call injectProtocol(context, cans) })`
- `check(event)`:
  - Guard: if not activated, throw
  - Create traceId
  - Iterate layers with short-circuit-on-deny
  - For each layer result: audit.log() with action 'hardening_check', target: event.toolName, outcome: allowed/denied, details: { layer, reason }, trace_id
  - If denied: also set blocking_layer and blocked_reason fields
  - Return final result
- `injectProtocol(cans)`: Return `extractProtocolRules(cans).split('\n')`

Update `src/hardening/index.ts` to add new exports:
- Export `{ checkToolPolicy }` from `./layers/tool-policy.js`
- Export `{ checkExecAllowlist }` from `./layers/exec-allowlist.js`
- Export `{ checkCansInjection, extractProtocolRules, injectProtocol }` from `./layers/cans-injection.js`
- Export `{ checkDockerSandbox, detectDocker }` from `./layers/docker-sandbox.js`
- Export `{ setupCanary }` from `./canary.js`
- Export `HardeningLayerFn` from `./types.js`

Also update `src/hardening/types.ts` if any type adjustments are needed from Plan 01 (HardeningLayerFn should already be there).

Run tests: all MUST PASS (GREEN).
  </action>
  <verify>
    `npx vitest run test/unit/hardening/hardening.test.ts` -- all 14 tests pass.
    `npx vitest run test/unit/hardening/` -- all tests pass (engine + layers).
  </verify>
  <done>
    Engine orchestrator composes all 4 layers with short-circuit-on-deny. Every check audit-logs per-layer decisions. activate() wires both hooks. Old stub tests replaced with 14 comprehensive implementation tests.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement canary module (HARD-07) with TDD</name>
  <files>
    src/hardening/canary.ts
    test/unit/hardening/canary.test.ts
  </files>
  <action>
**Step 1: RED — Write failing canary tests**

Create `test/unit/hardening/canary.test.ts`:
- Import `setupCanary` (will not exist yet)
- Use `vi.useFakeTimers()` to control setTimeout behavior

Test cases:
1. `setupCanary()` returns an object with `isVerified()` and `markVerified()` methods
2. `isVerified()` returns false initially
3. After `markVerified()`, `isVerified()` returns true
4. `markVerified()` calls `audit.log()` with `action: 'hook_canary'`, `outcome: 'allowed'`, `details.status: 'verified'`
5. Multiple `markVerified()` calls only log once (idempotent)
6. After 30 seconds without `markVerified()`, adapter.log('warn', ...) is called with degradation warning
7. After 30 seconds without `markVerified()`, audit.log() is called with `outcome: 'error'` and `status: 'not_fired'`
8. If `markVerified()` is called before timeout, the timeout warning does NOT fire (advance timer past 30s and verify no warn log)
9. Returned timeout has `.unref()` called (does not keep Node.js alive)

Run tests: all MUST FAIL (RED).

**Step 2: GREEN — Implement canary**

Create `src/hardening/canary.ts`:

```typescript
import type { PlatformAdapter } from '../adapters/types.js';
import type { AuditPipeline } from '../audit/pipeline.js';

const CANARY_TIMEOUT_MS = 30_000;

export interface CanaryHandle {
  isVerified: () => boolean;
  markVerified: () => void;
}

export function setupCanary(
  adapter: PlatformAdapter,
  audit: AuditPipeline,
): CanaryHandle {
  let verified = false;

  const timeoutId = setTimeout(() => {
    if (!verified) {
      adapter.log('warn', '[CareAgent] before_tool_call hook did NOT fire. Safety Guard is degraded.');
      audit.log({
        action: 'hook_canary',
        actor: 'system',
        outcome: 'error',
        details: {
          hook: 'before_tool_call',
          status: 'not_fired',
          message: 'Safety Guard Layer 5 is degraded -- hook not wired by host platform',
        },
      });
    }
  }, CANARY_TIMEOUT_MS);

  if (timeoutId && typeof timeoutId === 'object' && 'unref' in timeoutId) {
    (timeoutId as NodeJS.Timeout).unref();
  }

  return {
    isVerified: () => verified,
    markVerified: () => {
      if (!verified) {
        verified = true;
        audit.log({
          action: 'hook_canary',
          actor: 'system',
          outcome: 'allowed',
          details: { hook: 'before_tool_call', status: 'verified' },
        });
      }
    },
  };
}
```

Run tests: all MUST PASS (GREEN).
  </action>
  <verify>
    `npx vitest run test/unit/hardening/canary.test.ts` -- all 9 tests pass.
    `npx vitest run test/unit/hardening/` -- all tests pass.
    `npx vitest run` -- full suite passes with no regressions.
  </verify>
  <done>
    Canary module (HARD-07) tracks hook liveness with 30s timeout. Verified on first before_tool_call. Idempotent markVerified. Warns provider when hook does not fire. Timer unref'd to avoid keeping Node.js alive.
  </done>
</task>

</tasks>

<verification>
- `npx vitest run test/unit/hardening/` passes all tests (engine + canary + 4 layers)
- `npx vitest run` full suite passes (no regressions)
- Old 7 stub tests replaced with 14+ engine tests and 9 canary tests
- Engine composes all 4 layers in order, short-circuits on deny
- Every check() call produces audit log entries
- Denied actions have blocking_layer and blocked_reason in audit
- Canary integrates with engine lifecycle
</verification>

<success_criteria>
- createHardeningEngine() returns a real implementation (not stubs)
- activate() wires adapter.onBeforeToolCall and adapter.onAgentBootstrap
- check() composes 4 layers with short-circuit-on-deny and full audit logging
- injectProtocol() extracts CANS rules for system prompt
- Canary tracks hook liveness with 30s timeout and warning
- 23+ tests across engine and canary (replacing 7 stub tests)
</success_criteria>

<output>
After completion, create `.planning/phases/03-runtime-hardening/03-03-SUMMARY.md`
</output>
