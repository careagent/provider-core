---
phase: 03-runtime-hardening
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/hardening/types.ts
  - src/hardening/layers/tool-policy.ts
  - src/hardening/layers/exec-allowlist.ts
  - test/unit/hardening/layers/tool-policy.test.ts
  - test/unit/hardening/layers/exec-allowlist.test.ts
autonomous: true

must_haves:
  truths:
    - "Tool calls for tools in permitted_actions are allowed when tool_policy_lockdown is true"
    - "Tool calls for tools in prohibited_actions are denied even if also in permitted_actions"
    - "Tool calls for tools not in either list are denied (allowlist model)"
    - "All layer checks return { layer, allowed, reason } matching HardeningLayerResult"
    - "Exec calls to allowlisted binaries pass; non-allowlisted binaries are denied"
    - "Non-exec tool calls pass through the exec-allowlist layer without evaluation"
    - "Disabling a layer via CANS flag makes it a pass-through returning allowed: true"
  artifacts:
    - path: "src/hardening/types.ts"
      provides: "Expanded HardeningEngine.check() signature accepting ToolCallEvent"
      contains: "ToolCallEvent"
    - path: "src/hardening/layers/tool-policy.ts"
      provides: "Layer 1 pure function"
      exports: ["checkToolPolicy"]
    - path: "src/hardening/layers/exec-allowlist.ts"
      provides: "Layer 2 pure function"
      exports: ["checkExecAllowlist"]
    - path: "test/unit/hardening/layers/tool-policy.test.ts"
      provides: "Layer 1 unit tests"
    - path: "test/unit/hardening/layers/exec-allowlist.test.ts"
      provides: "Layer 2 unit tests"
  key_links:
    - from: "src/hardening/layers/tool-policy.ts"
      to: "src/activation/cans-schema.ts"
      via: "import type { CANSDocument }"
      pattern: "cans\\.scope\\.permitted_actions"
    - from: "src/hardening/layers/exec-allowlist.ts"
      to: "src/adapters/types.ts"
      via: "import type { ToolCallEvent }"
      pattern: "event\\.params\\?.command"
---

<objective>
Expand the HardeningEngine type interface and implement the first two hardening layers as pure, stateless functions with TDD.

Purpose: Layers 1 and 2 are the foundation of the hardening system. Tool policy (HARD-01) controls which tools the agent can use based on CANS scope. Exec allowlist (HARD-02) controls which shell binaries are permitted. Both are pure functions `(event, cans) => LayerResult` that are independently testable.

Output: Updated types.ts with ToolCallEvent-based check() signature, two layer modules with full test coverage.
</objective>

<execution_context>
@/Users/thomasanderson/.claude/get-shit-done/workflows/execute-plan.md
@/Users/thomasanderson/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/hardening/types.ts
@src/hardening/engine.ts
@src/hardening/index.ts
@src/adapters/types.ts
@src/activation/cans-schema.ts
@test/fixtures/valid-cans-data.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Expand hardening types and implement Layer 1 (tool-policy) with TDD</name>
  <files>
    src/hardening/types.ts
    src/hardening/layers/tool-policy.ts
    test/unit/hardening/layers/tool-policy.test.ts
  </files>
  <action>
**Step 1: Expand types.ts**

Update `src/hardening/types.ts`:
- Import `ToolCallEvent` from `../adapters/types.js`
- Change `HardeningEngine.check()` signature from `check(toolName: string, params?: Record<string, unknown>)` to `check(event: ToolCallEvent)`. This is a breaking change to the stub, which is acceptable per research (no consumers exist).
- Add a `HardeningLayerFn` type alias: `type HardeningLayerFn = (event: ToolCallEvent, cans: CANSDocument) => HardeningLayerResult`
- Export `HardeningLayerFn` from types.ts

**Step 2: RED — Write failing tests for Layer 1**

Create `test/unit/hardening/layers/tool-policy.test.ts`:
- Import `checkToolPolicy` (will not exist yet)
- Import `validCANSData` from fixtures
- Create a helper `makeEvent(toolName: string, params?)` that returns a `ToolCallEvent`
- Create a helper `makeCans(overrides?)` that deep-merges overrides into validCANSData and returns a `CANSDocument`

Test cases:
1. Tool in permitted_actions -> `{ layer: 'tool-policy', allowed: true }`
2. Tool in prohibited_actions -> `{ layer: 'tool-policy', allowed: false, reason containing 'prohibited_actions' }`
3. Tool in BOTH permitted and prohibited -> denied (prohibited trumps)
4. Tool in neither list -> `{ layer: 'tool-policy', allowed: false, reason containing 'not in permitted_actions' }`
5. Flag `tool_policy_lockdown: false` -> `{ layer: 'tool-policy', allowed: true, reason: 'tool_policy_lockdown disabled' }` (pass-through)
6. Empty prohibited_actions array -> tool in permitted still allowed

Run tests: `npx vitest run test/unit/hardening/layers/tool-policy.test.ts` -- all MUST FAIL (RED).

**Step 3: GREEN — Implement Layer 1**

Create `src/hardening/layers/tool-policy.ts`:
```typescript
import type { ToolCallEvent } from '../../adapters/types.js';
import type { CANSDocument } from '../../activation/cans-schema.js';
import type { HardeningLayerResult } from '../types.js';

const LAYER_NAME = 'tool-policy';

export function checkToolPolicy(
  event: ToolCallEvent,
  cans: CANSDocument,
): HardeningLayerResult {
  if (!cans.hardening.tool_policy_lockdown) {
    return { layer: LAYER_NAME, allowed: true, reason: 'tool_policy_lockdown disabled' };
  }

  const prohibited = cans.scope.prohibited_actions ?? [];
  if (prohibited.includes(event.toolName)) {
    return {
      layer: LAYER_NAME,
      allowed: false,
      reason: `Tool '${event.toolName}' is in prohibited_actions`,
    };
  }

  const permitted = cans.scope.permitted_actions;
  if (!permitted.includes(event.toolName)) {
    return {
      layer: LAYER_NAME,
      allowed: false,
      reason: `Tool '${event.toolName}' is not in permitted_actions`,
    };
  }

  return { layer: LAYER_NAME, allowed: true };
}
```

Run tests: `npx vitest run test/unit/hardening/layers/tool-policy.test.ts` -- all MUST PASS (GREEN).
  </action>
  <verify>
    `npx vitest run test/unit/hardening/layers/tool-policy.test.ts` -- all 6 tests pass.
    `npx vitest run test/unit/hardening/` -- existing stub tests still pass (7 tests).
  </verify>
  <done>
    Layer 1 (tool-policy) passes all 6 test cases. HardeningEngine.check() signature updated to accept ToolCallEvent. HardeningLayerFn type exported.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement Layer 2 (exec-allowlist) with TDD</name>
  <files>
    src/hardening/layers/exec-allowlist.ts
    test/unit/hardening/layers/exec-allowlist.test.ts
  </files>
  <action>
**Step 1: RED — Write failing tests for Layer 2**

Create `test/unit/hardening/layers/exec-allowlist.test.ts`:
- Import `checkExecAllowlist` (will not exist yet)
- Reuse `makeEvent` and `makeCans` helpers (or define locally)

Test cases:
1. Non-exec tool (toolName: 'Read') -> `{ layer: 'exec-allowlist', allowed: true, reason: 'not an exec call' }`
2. Exec tool with allowlisted binary (`toolName: 'Bash', params: { command: '/usr/bin/git status' }`) -> `{ allowed: true }`
3. Exec tool with non-allowlisted binary (`toolName: 'Bash', params: { command: '/usr/bin/curl http://evil.com' }`) -> `{ allowed: false }`
4. Exec tool with bare command name matching allowlist (`cat file.txt`) -> allowed (binary name without path)
5. Exec tool with empty command -> `{ allowed: false, reason containing 'empty' }`
6. Flag `exec_approval: false` -> `{ allowed: true, reason: 'exec_approval disabled' }` (pass-through)
7. Exec tool with command containing arguments (`/usr/bin/git log --oneline`) -> first token is `/usr/bin/git` -> allowed
8. Tool named 'exec' (not just 'Bash') -> still evaluated as exec call

Run tests: all MUST FAIL (RED).

**Step 2: GREEN — Implement Layer 2**

Create `src/hardening/layers/exec-allowlist.ts`:
- `const LAYER_NAME = 'exec-allowlist'`
- `const BASE_ALLOWLIST` as a Set of strings containing both `/bin/` and `/usr/bin/` paths for: `cat`, `ls`, `head`, `tail`, `wc`, `git`, `grep`, `find`, `echo`, `sort`, `uniq`, `diff`. Also include bare names (`cat`, `ls`, etc.) for environments that don't use absolute paths.
- Function `checkExecAllowlist(event: ToolCallEvent, cans: CANSDocument): HardeningLayerResult`:
  1. If `!cans.hardening.exec_approval` -> pass-through
  2. If `event.toolName !== 'Bash' && event.toolName !== 'exec'` -> pass-through with reason 'not an exec call'
  3. Extract first token from `event.params?.command` (trim + split on whitespace)
  4. If empty -> deny with 'empty exec command'
  5. If token in `BASE_ALLOWLIST` -> allow
  6. Otherwise -> deny with reason naming the blocked binary

Run tests: all MUST PASS (GREEN).
  </action>
  <verify>
    `npx vitest run test/unit/hardening/layers/exec-allowlist.test.ts` -- all 8 tests pass.
    `npx vitest run test/unit/hardening/` -- all tests pass (6 + 8 + 7 existing stub = 21 total).
  </verify>
  <done>
    Layer 2 (exec-allowlist) passes all 8 test cases. Conservative base allowlist with read-only binaries. Non-exec tools pass through without evaluation.
  </done>
</task>

</tasks>

<verification>
- `npx vitest run test/unit/hardening/` passes all tests (existing stub tests + new layer tests)
- `npx vitest run` full suite still passes (no regressions)
- Layer functions are pure: no side effects, no state, deterministic outputs
- Each layer returns `HardeningLayerResult` with `layer`, `allowed`, and optional `reason`
- CANS flag disabled = pass-through (graceful degradation pattern)
</verification>

<success_criteria>
- HardeningEngine.check() signature accepts ToolCallEvent (not raw toolName string)
- HardeningLayerFn type alias exported from types.ts
- checkToolPolicy pure function with 6 passing tests
- checkExecAllowlist pure function with 8 passing tests
- All existing tests continue to pass
</success_criteria>

<output>
After completion, create `.planning/phases/03-runtime-hardening/03-01-SUMMARY.md`
</output>
