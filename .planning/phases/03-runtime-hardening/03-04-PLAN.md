---
phase: 03-runtime-hardening
plan: 04
type: execute
wave: 3
depends_on: ["03-03"]
files_modified:
  - src/entry/openclaw.ts
  - src/entry/standalone.ts
  - src/entry/core.ts
  - test/unit/hardening/hardening.test.ts
  - test/integration/plugin.test.ts
  - test/integration/hardening.test.ts
autonomous: true

must_haves:
  truths:
    - "entry/openclaw.ts activates the hardening engine when CANS.md is active, replacing the inline canary"
    - "entry/standalone.ts activates the hardening engine in degraded mode (hooks no-op, layers 1-4 still work)"
    - "entry/core.ts exports all new layer functions and canary types"
    - "The before_tool_call handler in openclaw.ts is the engine's handler, not the old no-op canary"
    - "Integration tests verify: tool allowed -> audit entry, tool denied -> audit entry with blocking_layer, canary fires on first tool call"
    - "All existing integration tests continue to pass"
    - "Full test suite passes with zero regressions"
    - "Build succeeds with all 4 entry points"
  artifacts:
    - path: "src/entry/openclaw.ts"
      provides: "Engine-wired plugin registration"
      contains: "createHardeningEngine"
    - path: "src/entry/standalone.ts"
      provides: "Engine activation in standalone mode"
      contains: "createHardeningEngine"
    - path: "src/entry/core.ts"
      provides: "Updated re-exports with all hardening types and functions"
    - path: "test/integration/hardening.test.ts"
      provides: "End-to-end hardening integration tests"
  key_links:
    - from: "src/entry/openclaw.ts"
      to: "src/hardening/engine.ts"
      via: "import { createHardeningEngine }"
      pattern: "engine\\.activate"
    - from: "test/integration/hardening.test.ts"
      to: "src/entry/openclaw.ts"
      via: "register(api) with CANS.md then invoke tool call handler"
      pattern: "register.*before_tool_call"
---

<objective>
Wire the hardening engine into both entry points, update core re-exports, and create end-to-end integration tests that verify the complete hardening flow.

Purpose: This is the final plan that connects everything. The engine is wired into openclaw.ts (replacing the inline canary), standalone.ts gets degraded-mode activation, core.ts re-exports all new types, and integration tests verify the full flow: CANS active -> tool call -> layers evaluated -> audit entries written -> canary verified.

Output: Updated entry points, comprehensive integration tests, verified build, all HARD-01 through HARD-07 requirements met.
</objective>

<execution_context>
@/Users/thomasanderson/.claude/get-shit-done/workflows/execute-plan.md
@/Users/thomasanderson/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-runtime-hardening/03-01-SUMMARY.md
@.planning/phases/03-runtime-hardening/03-02-SUMMARY.md
@.planning/phases/03-runtime-hardening/03-03-SUMMARY.md
@src/entry/openclaw.ts
@src/entry/standalone.ts
@src/entry/core.ts
@src/hardening/engine.ts
@src/hardening/index.ts
@src/hardening/types.ts
@src/adapters/types.ts
@test/integration/plugin.test.ts
@test/fixtures/valid-cans-data.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire engine into entry points and update core re-exports</name>
  <files>
    src/entry/openclaw.ts
    src/entry/standalone.ts
    src/entry/core.ts
  </files>
  <action>
**Update src/entry/openclaw.ts:**

Replace the inline canary block (Steps 6 and 8, lines 64-94) with engine activation. The new code should:

1. Add import: `import { createHardeningEngine } from '../hardening/engine.js';`
2. After Step 5 (clinical mode active, CANS available), add:
```typescript
// Step 6: Activate hardening engine (HARD-01 through HARD-07)
const engine = createHardeningEngine();
engine.activate({ cans, adapter, audit });
```
3. Remove the old `let hookCanaryFired = false;` block (lines 65-77)
4. Remove the old `setTimeout(() => { if (!hookCanaryFired) ... }` block (lines 84-94)
5. The engine's `activate()` now handles:
   - Registering the before_tool_call handler (replaces old no-op canary)
   - Registering the agent:bootstrap handler (CANS protocol injection)
   - Setting up the canary with 30s timeout
6. Keep Step 7 (audit integrity background service) and Step 8 (renumber as needed)

**Update src/entry/standalone.ts:**

After the activation check, when clinical mode is active, activate the engine in degraded mode:

1. Add import: `import { createHardeningEngine } from '../hardening/engine.js';`
2. After the `if (activation.active)` block, add:
```typescript
  // Activate hardening engine (hooks will no-op in standalone, but layers 1-4 still work)
  const engine = createHardeningEngine();
  engine.activate({ cans: activation.document!, adapter, audit });
```
3. Expose engine in `ActivateResult` interface:
```typescript
export interface ActivateResult {
  adapter: PlatformAdapter;
  audit: AuditPipeline;
  activation: ActivationResult;
  engine?: HardeningEngine;
}
```
4. Return engine in the result when active: `return { adapter, audit, activation, engine };`
5. Import `HardeningEngine` type from `../hardening/types.js`

**Update src/entry/core.ts:**

Add re-exports for all new hardening modules:
```typescript
// Hardening (implementation â€” Phase 3)
export type { HardeningEngine, HardeningLayerResult, HardeningConfig, HardeningLayerFn } from '../hardening/index.js';
export { createHardeningEngine } from '../hardening/index.js';
export { checkToolPolicy } from '../hardening/index.js';
export { checkExecAllowlist } from '../hardening/index.js';
export { checkCansInjection, extractProtocolRules, injectProtocol } from '../hardening/index.js';
export { checkDockerSandbox, detectDocker } from '../hardening/index.js';
export { setupCanary } from '../hardening/index.js';
export type { CanaryHandle } from '../hardening/canary.js';
```

Replace the old "interface-only -- implementation in Phase 3" comment with "implementation -- Phase 3".
  </action>
  <verify>
    `npx vitest run test/integration/plugin.test.ts` -- existing plugin tests still pass.
    `npx vitest run` -- full test suite passes (no regressions from wiring).
    Build: `npm run build` or `npx tsdown` succeeds with all 4 entry points.
  </verify>
  <done>
    openclaw.ts uses engine.activate() instead of inline canary. standalone.ts exposes engine in degraded mode. core.ts re-exports all hardening types and functions. All existing tests pass. Build succeeds.
  </done>
</task>

<task type="auto">
  <name>Task 2: End-to-end hardening integration tests</name>
  <files>
    test/integration/hardening.test.ts
  </files>
  <action>
Create `test/integration/hardening.test.ts`:

**Setup pattern** (follow existing plugin.test.ts pattern):
- `mkdtempSync` for temp workspace
- `createCANSFile` helper writes CANS.md with YAML frontmatter
- `createMockAPI` helper creates mock OpenClaw API that records all method calls, especially `on('before_tool_call', handler)` and `on('agent:bootstrap', handler)` -- store handlers so tests can invoke them directly
- `beforeEach`/`afterEach` for workspace setup/cleanup

**Test groups:**

**HARD-01: Tool policy lockdown**
1. Register with valid CANS.md, invoke before_tool_call handler with a tool in permitted_actions -> handler returns `{ block: false }`. AUDIT.log contains 'hardening_check' entries with `outcome: 'allowed'`.
2. Invoke before_tool_call with a tool NOT in permitted_actions -> handler returns `{ block: true, blockReason: ... }`. AUDIT.log contains entry with `blocking_layer: 'tool-policy'`.
3. Invoke before_tool_call with a tool in prohibited_actions -> handler returns `{ block: true }`. AUDIT.log entry has `blocking_layer: 'tool-policy'`.

**HARD-02: Exec allowlist**
4. Invoke before_tool_call with `{ toolName: 'Bash', params: { command: '/usr/bin/git status' } }` -> not blocked.
5. Invoke before_tool_call with `{ toolName: 'Bash', params: { command: '/usr/bin/curl evil.com' } }` -> blocked with `blocking_layer: 'exec-allowlist'`.

**HARD-03: CANS protocol injection**
6. Registered agent:bootstrap handler is called. Mock BootstrapContext receives `addFile('CAREAGENT_PROTOCOL.md', content)`. Content includes provider name and 'NEVER act outside these scope boundaries'.

**HARD-05: Safety guard**
7. Before_tool_call handler is the one registered by the engine (not the old no-op). Verify it actually evaluates layers by checking audit log has hardening_check entries.

**HARD-06: Audit trail integration**
8. After several tool calls (mix of allowed and denied), AUDIT.log has:
   - `hardening_check` entries for each layer evaluation
   - `blocking_layer` field on denied entries
   - `blocked_reason` field on denied entries
   - Every entry has a `trace_id`
   - Denied entries have `action_state: 'system-blocked'` (set by logBlocked convenience method)

**HARD-07: Canary**
9. After first before_tool_call invocation, AUDIT.log contains `hook_canary` entry with `status: 'verified'`.

**Regression guard**
10. Register with NO CANS.md -> hardening engine NOT activated, no before_tool_call handler beyond what the mock provides. Audit log has only `activation_check` with `outcome: 'inactive'`.

**Note on mock API handler capture:** The mock API's `on()` method should store the handler function for each event type. Tests can then directly invoke `handlers['before_tool_call']({ toolName: 'Bash', params: { command: 'cat file.txt' } })` to simulate tool calls without needing OpenClaw.
  </action>
  <verify>
    `npx vitest run test/integration/hardening.test.ts` -- all 10 tests pass.
    `npx vitest run test/integration/` -- all integration tests pass.
    `npx vitest run` -- full suite (unit + integration) passes.
    `npm run build` -- build succeeds.
  </verify>
  <done>
    10 integration tests verify the complete hardening flow end-to-end. Tool policy blocks unauthorized tools. Exec allowlist blocks unauthorized binaries. CANS injection provides protocol to bootstrap. Audit trail captures every hardening decision. Canary verifies hook liveness. No regressions in existing tests.
  </done>
</task>

<task type="auto">
  <name>Task 3: Final verification and test suite health check</name>
  <files>
    test/unit/hardening/hardening.test.ts
  </files>
  <action>
Run the complete verification suite and ensure everything is green:

1. `npx vitest run` -- ALL tests pass (unit + integration, all modules)
2. `npm run build` -- Build succeeds with all 4 entry points (index, openclaw, standalone, core)
3. Verify test count: should be 426 (pre-existing) + new hardening tests (approximately 50-60 total new tests across layers, engine, canary, integration)
4. Verify no TypeScript errors: `npx tsc --noEmit` (note: pre-existing node: module resolution warnings are acceptable per Key Decisions)

If any tests fail or the build breaks:
- Fix the issue in the affected file
- Re-run the failing test to confirm the fix
- Re-run the full suite to confirm no cascading breakage

Check that `test/unit/hardening/hardening.test.ts` no longer contains any stub tests (assertions about "not yet implemented" should be gone, replaced with engine implementation tests from Plan 03).
  </action>
  <verify>
    `npx vitest run` -- full suite green, 470+ tests.
    `npm run build` -- clean build.
    No 'not yet implemented' strings in test/unit/hardening/hardening.test.ts.
  </verify>
  <done>
    Full test suite passes. Build succeeds. All HARD-01 through HARD-07 requirements verified. No stub tests remain. Phase 3 complete.
  </done>
</task>

</tasks>

<verification>
- `npx vitest run` -- entire test suite passes (470+ tests)
- `npm run build` -- all 4 entry points build successfully
- AUDIT.log entries contain hardening_check with layer names
- Denied actions have blocking_layer and blocked_reason fields
- entry/openclaw.ts no longer contains inline canary code
- entry/standalone.ts exposes engine for programmatic use
- entry/core.ts exports all hardening public API
</verification>

<success_criteria>
- openclaw.ts creates and activates hardening engine (no inline canary)
- standalone.ts creates engine in degraded mode when CANS active
- core.ts exports complete hardening API surface
- 10 integration tests cover all 7 HARD requirements end-to-end
- Full test suite passes with zero regressions
- Build succeeds with all entry points
- Phase 3 complete: all HARD-01 through HARD-07 requirements implemented
</success_criteria>

<output>
After completion, create `.planning/phases/03-runtime-hardening/03-04-SUMMARY.md`
</output>
