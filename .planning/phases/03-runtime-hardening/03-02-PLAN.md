---
phase: 03-runtime-hardening
plan: 02
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/hardening/layers/cans-injection.ts
  - src/hardening/layers/docker-sandbox.ts
  - test/unit/hardening/layers/cans-injection.test.ts
  - test/unit/hardening/layers/docker-sandbox.test.ts
autonomous: true

must_haves:
  truths:
    - "extractProtocolRules() produces a concise string with provider name, specialty, scope boundaries, prohibited actions, and autonomy tiers"
    - "Protocol injection content is under 500 tokens (approximately 2000 characters)"
    - "Docker detection checks multiple signals: /.dockerenv, /proc/1/cgroup, CONTAINER env var"
    - "Docker layer is report-only: it never blocks tool calls, only reports sandbox status"
    - "Both layers respect their CANS flag (disabled = pass-through)"
  artifacts:
    - path: "src/hardening/layers/cans-injection.ts"
      provides: "Layer 3: extractProtocolRules() and injectProtocol()"
      exports: ["extractProtocolRules", "injectProtocol", "checkCansInjection"]
    - path: "src/hardening/layers/docker-sandbox.ts"
      provides: "Layer 4: Docker container detection and sandbox reporting"
      exports: ["detectDocker", "checkDockerSandbox"]
    - path: "test/unit/hardening/layers/cans-injection.test.ts"
      provides: "Layer 3 unit tests"
    - path: "test/unit/hardening/layers/docker-sandbox.test.ts"
      provides: "Layer 4 unit tests"
  key_links:
    - from: "src/hardening/layers/cans-injection.ts"
      to: "src/adapters/types.ts"
      via: "import type { BootstrapContext }"
      pattern: "context\\.addFile"
    - from: "src/hardening/layers/docker-sandbox.ts"
      to: "node:fs"
      via: "existsSync for container detection"
      pattern: "existsSync.*dockerenv"
---

<objective>
Implement Layers 3 (CANS protocol injection) and 4 (Docker sandbox detection) as pure, testable functions with TDD.

Purpose: Layer 3 (HARD-03) extracts clinical hard rules from CANS and injects them into the agent's system prompt via the bootstrap hook so the agent knows its scope boundaries. Layer 4 (HARD-04) detects whether the runtime is inside a Docker container and reports sandbox status. Both are independently testable and do not require hooks to be wired.

Output: Two layer modules with test coverage. Layer 3 provides both a bootstrap injection function and a per-check function. Layer 4 provides a detection function and a per-check function.
</objective>

<execution_context>
@/Users/thomasanderson/.claude/get-shit-done/workflows/execute-plan.md
@/Users/thomasanderson/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/adapters/types.ts
@src/activation/cans-schema.ts
@src/hardening/types.ts
@test/fixtures/valid-cans-data.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement Layer 3 (CANS protocol injection) with TDD</name>
  <files>
    src/hardening/layers/cans-injection.ts
    test/unit/hardening/layers/cans-injection.test.ts
  </files>
  <action>
**Step 1: RED — Write failing tests for Layer 3**

Create `test/unit/hardening/layers/cans-injection.test.ts`:
- Import `extractProtocolRules`, `injectProtocol`, `checkCansInjection` (will not exist yet)
- Import `validCANSData` from fixtures; cast to `CANSDocument` as needed

Tests for `extractProtocolRules()`:
1. Output includes provider name and specialty from CANS
2. Output includes "PROHIBITED" section with prohibited_actions
3. Output includes autonomy tiers (chart: autonomous, order: supervised, etc.)
4. Output includes institutional limitations
5. Output includes "NEVER act outside these scope boundaries" instruction
6. Output length is under 2000 characters (proxy for <500 tokens)
7. When prohibited_actions is empty/undefined, "PROHIBITED" section is omitted

Tests for `injectProtocol()`:
8. Calls `context.addFile('CAREAGENT_PROTOCOL.md', content)` where content matches extractProtocolRules output
9. Mock BootstrapContext records the addFile call correctly

Tests for `checkCansInjection()` (per-call layer function for engine composition):
10. When `cans_protocol_injection: true` -> `{ layer: 'cans-injection', allowed: true, reason: 'protocol injected at bootstrap' }`
11. When `cans_protocol_injection: false` -> `{ layer: 'cans-injection', allowed: true, reason: 'cans_protocol_injection disabled' }`
(Note: Layer 3 never blocks tool calls. It acts at bootstrap time. The per-check function is always a pass-through that reports injection status.)

Run tests: all MUST FAIL (RED).

**Step 2: GREEN — Implement Layer 3**

Create `src/hardening/layers/cans-injection.ts`:

```typescript
import type { ToolCallEvent } from '../../adapters/types.js';
import type { BootstrapContext } from '../../adapters/types.js';
import type { CANSDocument } from '../../activation/cans-schema.js';
import type { HardeningLayerResult } from '../types.js';

const LAYER_NAME = 'cans-injection';

export function extractProtocolRules(cans: CANSDocument): string {
  const lines: string[] = [];
  lines.push('# CareAgent Clinical Protocol');
  lines.push('');
  lines.push(`Provider: ${cans.provider.name} (${cans.provider.license.type})`);
  lines.push(`Specialty: ${cans.provider.specialty}`);
  if (cans.provider.subspecialty) {
    lines.push(`Subspecialty: ${cans.provider.subspecialty}`);
  }
  if (cans.provider.institution) {
    lines.push(`Institution: ${cans.provider.institution}`);
  }
  lines.push('');
  lines.push('## Scope Boundaries (HARD RULES)');
  lines.push(`Permitted: ${cans.scope.permitted_actions.join(', ')}`);
  if (cans.scope.prohibited_actions?.length) {
    lines.push(`PROHIBITED: ${cans.scope.prohibited_actions.join(', ')}`);
  }
  if (cans.scope.institutional_limitations?.length) {
    lines.push(`Limitations: ${cans.scope.institutional_limitations.join(', ')}`);
  }
  lines.push('');
  lines.push('## Autonomy Tiers');
  lines.push(`Chart: ${cans.autonomy.chart} | Order: ${cans.autonomy.order} | Charge: ${cans.autonomy.charge} | Perform: ${cans.autonomy.perform}`);
  lines.push('');
  lines.push('NEVER act outside these scope boundaries. If uncertain, ASK the provider.');
  return lines.join('\n');
}

export function injectProtocol(context: BootstrapContext, cans: CANSDocument): void {
  const rules = extractProtocolRules(cans);
  context.addFile('CAREAGENT_PROTOCOL.md', rules);
}

export function checkCansInjection(
  _event: ToolCallEvent,
  cans: CANSDocument,
): HardeningLayerResult {
  if (!cans.hardening.cans_protocol_injection) {
    return { layer: LAYER_NAME, allowed: true, reason: 'cans_protocol_injection disabled' };
  }
  return { layer: LAYER_NAME, allowed: true, reason: 'protocol injected at bootstrap' };
}
```

Run tests: all MUST PASS (GREEN).
  </action>
  <verify>
    `npx vitest run test/unit/hardening/layers/cans-injection.test.ts` -- all 11 tests pass.
  </verify>
  <done>
    Layer 3 (CANS injection) produces concise protocol rules under 2000 characters. injectProtocol() wires to BootstrapContext. checkCansInjection() is a non-blocking pass-through for engine composition.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement Layer 4 (Docker sandbox detection) with TDD</name>
  <files>
    src/hardening/layers/docker-sandbox.ts
    test/unit/hardening/layers/docker-sandbox.test.ts
  </files>
  <action>
**Step 1: RED — Write failing tests for Layer 4**

Create `test/unit/hardening/layers/docker-sandbox.test.ts`:
- Import `detectDocker`, `checkDockerSandbox` (will not exist yet)
- Use `vi.mock('node:fs')` to control `existsSync` and `readFileSync` behavior

Tests for `detectDocker()`:
1. When `/.dockerenv` exists -> `{ inContainer: true, signals: ['/.dockerenv exists'] }`
2. When `/proc/1/cgroup` contains 'docker' -> `{ inContainer: true, signals: ['/proc/1/cgroup contains container reference'] }`
3. When `CONTAINER` env var is set -> `{ inContainer: true, signals: ['CONTAINER env var set'] }`
4. When none of the signals are present -> `{ inContainer: false, signals: [] }`
5. Multiple signals present -> all listed in signals array
6. When `readFileSync` throws (e.g., macOS, no /proc) -> gracefully handled, not a signal

Tests for `checkDockerSandbox()`:
7. Flag `docker_sandbox: false` -> `{ layer: 'docker-sandbox', allowed: true, reason: 'docker_sandbox disabled' }`
8. Flag true, container detected -> `{ layer: 'docker-sandbox', allowed: true, reason containing 'sandbox active' }`
9. Flag true, no container detected -> `{ layer: 'docker-sandbox', allowed: true, reason containing 'no container detected' }`

**Important:** Layer 4 NEVER returns `allowed: false`. It is report-only. All tests should assert `allowed: true`.

Run tests: all MUST FAIL (RED).

**Step 2: GREEN — Implement Layer 4**

Create `src/hardening/layers/docker-sandbox.ts`:
- Import `existsSync`, `readFileSync` from `node:fs`
- `detectDocker()` function checking three signals (with try/catch around readFileSync)
- `checkDockerSandbox(event, cans)` function:
  1. Flag check
  2. Call detectDocker()
  3. Return allowed: true in all cases with descriptive reason

Use the approach from the research code examples. The function signature must match `HardeningLayerFn` from types.ts (accepting `ToolCallEvent` as first param even though it's unused -- prefix with underscore).

Run tests: all MUST PASS (GREEN).
  </action>
  <verify>
    `npx vitest run test/unit/hardening/layers/docker-sandbox.test.ts` -- all 9 tests pass.
    `npx vitest run test/unit/hardening/` -- all tests pass (existing + new layer tests).
  </verify>
  <done>
    Layer 4 (Docker sandbox) detects container environments via multiple signals. Never blocks tool calls. Reports sandbox status for audit logging. Gracefully handles missing /proc on non-Linux systems.
  </done>
</task>

</tasks>

<verification>
- `npx vitest run test/unit/hardening/` passes all tests
- `npx vitest run` full suite still passes (no regressions)
- Layer 3 extractProtocolRules output is under 2000 characters
- Layer 4 never returns allowed: false
- Both layers respect their CANS flag disabled state
</verification>

<success_criteria>
- extractProtocolRules() produces concise clinical rules including provider, scope, autonomy
- injectProtocol() calls BootstrapContext.addFile with protocol content
- checkCansInjection() is a non-blocking pass-through for engine composition
- detectDocker() checks /.dockerenv, /proc/1/cgroup, CONTAINER env var
- checkDockerSandbox() is report-only (always allowed: true)
- 20 new tests across both layers all pass
</success_criteria>

<output>
After completion, create `.planning/phases/03-runtime-hardening/03-02-SUMMARY.md`
</output>
