---
phase: 04-clinical-skills
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/skills/types.ts
  - src/skills/manifest-schema.ts
  - src/skills/integrity.ts
  - src/skills/version-pin.ts
  - test/unit/skills/manifest-schema.test.ts
  - test/unit/skills/integrity.test.ts
  - test/unit/skills/version-pin.test.ts
autonomous: true

must_haves:
  truths:
    - "A skill manifest JSON file can be validated against the TypeBox schema"
    - "SHA-256 checksums can be computed for skill files and verified against manifest values"
    - "A modified skill file causes integrity verification to fail with a clear reason"
    - "A missing skill file causes integrity verification to fail with a clear reason"
    - "Version pinning logic detects when available version differs from approved version"
    - "Version approval records the new approved version"
  artifacts:
    - path: "src/skills/types.ts"
      provides: "SkillManifest, SkillLoadResult, ChartTemplate, TemplateSection types"
      min_lines: 30
    - path: "src/skills/manifest-schema.ts"
      provides: "TypeBox schema for skill-manifest.json validation"
      exports: ["SkillManifestSchema"]
    - path: "src/skills/integrity.ts"
      provides: "Skill file SHA-256 checksumming and verification"
      exports: ["computeSkillFileHash", "verifySkillIntegrity", "computeSkillChecksums"]
    - path: "src/skills/version-pin.ts"
      provides: "Version pinning check and approval logic"
      exports: ["checkVersionPin", "approveVersion"]
  key_links:
    - from: "src/skills/integrity.ts"
      to: "src/activation/cans-integrity.ts"
      via: "reuses same node:crypto SHA-256 pattern (computeHash)"
      pattern: "createHash.*sha256"
    - from: "src/skills/manifest-schema.ts"
      to: "@sinclair/typebox"
      via: "TypeBox schema definition"
      pattern: "Type\\.Object"
---

<objective>
Create the skill framework core: types, manifest schema, integrity verification, and version pinning. These are the building blocks that the skill loader (Plan 04) and chart-skill (Plan 03) depend on.

Purpose: SKIL-03 (integrity verification) and SKIL-04 (version pinning) are implemented here as standalone, testable modules. The loader will compose them with credential validation.

Output: `src/skills/` module with types, manifest schema, integrity checker, and version-pin logic -- all with unit tests.
</objective>

<execution_context>
@/Users/thomasanderson/.claude/get-shit-done/workflows/execute-plan.md
@/Users/thomasanderson/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/activation/cans-integrity.ts
@src/activation/cans-schema.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Skill types and manifest schema</name>
  <files>src/skills/types.ts, src/skills/manifest-schema.ts, test/unit/skills/manifest-schema.test.ts</files>
  <action>
**Create `src/skills/types.ts`:**

Define the following types (not TypeBox schemas -- plain TypeScript interfaces):

```typescript
export interface SkillManifest {
  skill_id: string;
  version: string;
  requires: {
    license?: string[];
    specialty?: string[];
    privilege?: string[];
  };
  files: Record<string, string>;  // filename -> sha256 hex hash
  pinned: boolean;
  approved_version: string;
}

export interface SkillLoadResult {
  skillId: string;
  loaded: boolean;
  reason?: string;  // present when loaded=false
  version?: string; // present when loaded=true
  directory?: string; // present when loaded=true
}

export interface TemplateSection {
  name: string;
  required: boolean;
  description: string;
  format?: 'text' | 'list' | 'table';
}

export interface ChartTemplate {
  templateId: string;
  name: string;
  sections: TemplateSection[];
  version: string;
}

export interface VoiceDirectives {
  tone?: string;
  documentationStyle?: string;
  useEponyms?: boolean;
  abbreviationStyle?: string;
}
```

**Create `src/skills/manifest-schema.ts`:**

Define a TypeBox schema for validating `skill-manifest.json` files. Use `@sinclair/typebox`:

- `skill_id`: `Type.String({ minLength: 1 })`
- `version`: `Type.String({ pattern: '^\\d+\\.\\d+\\.\\d+$' })` (semver)
- `requires`: `Type.Object` with optional arrays for license, specialty, privilege
- `files`: `Type.Record(Type.String(), Type.String())` (filename -> hash)
- `pinned`: `Type.Boolean()`
- `approved_version`: `Type.String()`

Export both the schema and a `validateManifest(data: unknown)` function that uses `Value.Check` and `Value.Errors` from TypeBox to return `{ valid: true, manifest: SkillManifest } | { valid: false, errors: string[] }`.

Import `Value` from `@sinclair/typebox/value` (the same pattern used in CANS validation).

**Create `test/unit/skills/manifest-schema.test.ts`:**

Test cases:
- Valid manifest passes validation
- Missing skill_id fails
- Invalid version format fails (not semver)
- Missing files field fails
- Empty requires object passes (no credential requirements = regular skill)
- Extra fields are tolerated (TypeBox default)
- Returns parsed SkillManifest on success
- Returns error strings on failure with field paths
  </action>
  <verify>npx vitest run test/unit/skills/manifest-schema.test.ts --reporter=verbose</verify>
  <done>SkillManifest types defined, TypeBox schema validates manifests, all tests pass</done>
</task>

<task type="auto">
  <name>Task 2: Integrity verification and version pinning</name>
  <files>src/skills/integrity.ts, src/skills/version-pin.ts, test/unit/skills/integrity.test.ts, test/unit/skills/version-pin.test.ts</files>
  <action>
**Create `src/skills/integrity.ts`:**

Use `node:crypto` (createHash), `node:fs` (readFileSync, readdirSync), `node:path` (join) -- the same imports used in `src/activation/cans-integrity.ts`.

Export three functions:

1. `computeSkillFileHash(filePath: string): string` -- reads file content as utf-8, returns sha256 hex digest.

2. `computeSkillChecksums(skillDir: string): Record<string, string>` -- reads all files in skillDir, returns `{ filename: sha256hash }` map. Sort filenames for deterministic ordering. Use `readdirSync` with `{ withFileTypes: true }` and skip directories (only hash files).

3. `verifySkillIntegrity(skillDir: string, manifest: { files: Record<string, string> }): { valid: boolean; reason?: string }` -- for each entry in `manifest.files`, compute the actual hash and compare. Skip the `skill-manifest.json` entry itself (to avoid self-referential checksum issues -- the manifest file will have changed since the hash was computed if we hash the whole file). Return `{ valid: false, reason }` on first mismatch or missing file. Return `{ valid: true }` if all match.

**Create `src/skills/version-pin.ts`:**

Export two functions:

1. `checkVersionPin(manifest: SkillManifest, availableVersion?: string): { pinned: boolean; currentVersion: string; approvedVersion: string; updateAvailable: boolean; availableVersion?: string }` -- if `manifest.pinned` is true AND `availableVersion` is provided AND differs from `manifest.approved_version`, return `updateAvailable: true`. Otherwise `updateAvailable: false`.

2. `approveVersion(manifest: SkillManifest, newVersion: string): SkillManifest` -- returns a new manifest object (spread copy) with `approved_version` set to `newVersion` and `version` set to `newVersion`. Does NOT mutate the input.

Import `SkillManifest` from `./types.js`.

**Create `test/unit/skills/integrity.test.ts`:**

Use `mkdtempSync` + `writeFileSync` to create real temp skill directories. Test cases:
- Compute hash of a known string produces expected sha256
- computeSkillChecksums returns hashes for all files in a directory
- verifySkillIntegrity passes when hashes match
- verifySkillIntegrity fails when a file is modified (hash mismatch with truncated hashes in reason)
- verifySkillIntegrity fails when a file is missing (clear reason)
- verifySkillIntegrity skips skill-manifest.json entry
- computeSkillChecksums skips subdirectories

Clean up temp dirs in afterEach.

**Create `test/unit/skills/version-pin.test.ts`:**

Test cases:
- Pinned manifest with no available version: updateAvailable false
- Pinned manifest with same version: updateAvailable false
- Pinned manifest with different version: updateAvailable true
- Unpinned manifest with different version: updateAvailable false (pinned is false)
- approveVersion returns new object with updated version fields
- approveVersion does not mutate input
  </action>
  <verify>npx vitest run test/unit/skills/integrity.test.ts test/unit/skills/version-pin.test.ts --reporter=verbose</verify>
  <done>Integrity verification detects file modifications and missing files; version pinning detects available updates and supports approval</done>
</task>

</tasks>

<verification>
- `npx vitest run test/unit/skills/` passes all new tests
- `npx vitest run` still passes all 486+ existing tests
- `npm run build` succeeds
</verification>

<success_criteria>
- SkillManifest TypeBox schema validates valid manifests and rejects invalid ones
- SHA-256 integrity verification catches modified and missing files
- Version pinning detects when updates are available and supports version approval
- All tests pass with no regressions
</success_criteria>

<output>
After completion, create `.planning/phases/04-clinical-skills/04-02-SUMMARY.md`
</output>
