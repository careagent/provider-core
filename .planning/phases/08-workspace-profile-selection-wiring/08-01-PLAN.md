---
phase: 08-workspace-profile-selection-wiring
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/entry/openclaw.ts
  - src/cli/commands.ts
  - src/entry/standalone.ts
  - test/integration/production-wiring.test.ts
autonomous: true
requirements: [PORT-03]

must_haves:
  truths:
    - "detectPlatform() result is passed to getWorkspaceProfile() in openclaw entry point"
    - "getWorkspaceProfile() result is threaded through registerCLI() to runInitCommand()"
    - "standalone entry point resolves and exposes the workspace profile on ActivateResult"
    - "openclaw entry path selects openclawProfile for workspace supplementation"
    - "standalone entry path selects standaloneProfile for workspace supplementation"
    - "agentsStandardProfile is reachable via getWorkspaceProfile('agents-standard') and works end-to-end through runInitCommand"
  artifacts:
    - path: "src/entry/openclaw.ts"
      provides: "Profile resolution and forwarding to registerCLI"
      contains: "getWorkspaceProfile"
    - path: "src/cli/commands.ts"
      provides: "Profile parameter threading to runInitCommand"
      contains: "profile?: WorkspaceProfile"
    - path: "src/entry/standalone.ts"
      provides: "Profile resolution and exposure on ActivateResult"
      contains: "profile: WorkspaceProfile"
    - path: "test/integration/production-wiring.test.ts"
      provides: "PORT-03 integration tests for all three profiles"
      contains: "PORT-03"
  key_links:
    - from: "src/entry/openclaw.ts"
      to: "src/cli/commands.ts"
      via: "registerCLI(adapter, workspacePath, audit, profile)"
      pattern: "registerCLI\\(.*profile\\)"
    - from: "src/cli/commands.ts"
      to: "src/cli/init-command.ts"
      via: "runInitCommand(io, workspacePath, audit, profile)"
      pattern: "runInitCommand\\(.*profile\\)"
    - from: "src/entry/standalone.ts"
      to: "src/onboarding/workspace-profiles.ts"
      via: "getWorkspaceProfile(platform)"
      pattern: "getWorkspaceProfile\\(platform\\)"
---

<objective>
Wire detectPlatform() result into getWorkspaceProfile() in both entry points and thread the resolved profile through registerCLI() to runInitCommand(), so workspace supplementation selects the correct profile per platform. Add integration tests proving all three profiles are reachable end-to-end.

Purpose: Closes PORT-03 — workspace file supplementation is currently hardcoded to openclawProfile because no caller passes a profile to runInitCommand(). After this plan, the detected platform drives profile selection automatically.

Output: Three source files modified with parameter threading; integration tests covering openclaw, standalone, and agents-standard profile selection.
</objective>

<execution_context>
@/Users/medomatic/.claude/get-shit-done/workflows/execute-plan.md
@/Users/medomatic/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-workspace-profile-selection-wiring/08-RESEARCH.md
@.planning/phases/07-production-wiring-gap-closure/07-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire profile resolution in entry points and thread through registerCLI</name>
  <files>
    src/entry/openclaw.ts
    src/cli/commands.ts
    src/entry/standalone.ts
  </files>
  <action>
    Three changes to thread the workspace profile from entry points to runInitCommand:

    **1. `src/entry/openclaw.ts`** — Add import and call getWorkspaceProfile:
    - Add `import { getWorkspaceProfile } from '../onboarding/workspace-profiles.js';` to imports
    - After `const platform = detectPlatform(api);` (line 30), add: `const profile = getWorkspaceProfile(platform);`
    - Change `registerCLI(adapter, workspacePath, audit);` to `registerCLI(adapter, workspacePath, audit, profile);`

    **2. `src/cli/commands.ts`** — Add optional profile parameter:
    - Add `import type { WorkspaceProfile } from '../onboarding/workspace-profiles.js';` to imports
    - Change `registerCLI` signature to accept `profile?: WorkspaceProfile` as 4th parameter
    - Change the `runInitCommand(io, workspacePath, audit)` call inside careagent init handler to `runInitCommand(io, workspacePath, audit, profile)`

    **3. `src/entry/standalone.ts`** — Add profile to ActivateResult:
    - Add `import { getWorkspaceProfile } from '../onboarding/workspace-profiles.js';` to imports
    - Add `import type { WorkspaceProfile } from '../onboarding/workspace-profiles.js';` (can be combined with the value import)
    - Add `profile: WorkspaceProfile;` to the `ActivateResult` interface (required field, not optional — the profile is always determinable)
    - After `const platform = detectPlatform(undefined);` (line 48), add: `const profile = getWorkspaceProfile(platform);`
    - In the active return (line 143), add `profile` to the returned object
    - In the inactive return (line 153), add `profile` to the returned object

    IMPORTANT: Keep `profile` as an OPTIONAL parameter (`profile?: WorkspaceProfile`) in `registerCLI` and do NOT change `runInitCommand` signature (it already accepts optional profile). This avoids breaking existing test call sites that invoke these functions without a profile argument.

    Do NOT modify `src/cli/init-command.ts` or `src/onboarding/workspace-writer.ts` — they already accept and handle the optional profile correctly.
  </action>
  <verify>
    Run `npx vitest run` — all 706+ existing tests must pass with zero failures. The profile parameter is optional in registerCLI, so existing callers in tests are unaffected.
  </verify>
  <done>
    - `openclaw.ts` calls `getWorkspaceProfile(platform)` and passes the result to `registerCLI`
    - `commands.ts` accepts `profile?: WorkspaceProfile` and forwards it to `runInitCommand`
    - `standalone.ts` calls `getWorkspaceProfile(platform)` and includes `profile` in `ActivateResult`
    - All existing tests pass unchanged
  </done>
</task>

<task type="auto">
  <name>Task 2: Add PORT-03 integration tests for profile selection per platform</name>
  <files>
    test/integration/production-wiring.test.ts
  </files>
  <action>
    Extend `test/integration/production-wiring.test.ts` with a new PORT-03 section at the end of the file. Add the following imports at the top (merge with existing imports):

    ```typescript
    import { runInitCommand } from '../../src/cli/init-command.js';
    import { createMockIO } from '../helpers/mock-io.js';  // or create inline mock if helper doesn't exist
    import {
      openclawProfile,
      standaloneProfile,
      agentsStandardProfile,
      getWorkspaceProfile,
    } from '../../src/onboarding/workspace-profiles.js';
    import type { WorkspaceProfile } from '../../src/onboarding/workspace-profiles.js';
    ```

    If `createMockIO` helper does not exist, check for existing test patterns. The `runInitCommand` requires an `InterviewIO` object. Look at `test/unit/onboarding/` or `test/integration/onboarding.test.ts` for how existing tests create mock IO objects (typically `createMockIO(answers)` that pre-fills interview responses). Use the same pattern.

    Add these test sections:

    **Section: PORT-03 profile selection integration**

    ```typescript
    describe('PORT-03: workspace profile selection', () => {
      // Test 1: getWorkspaceProfile maps detectPlatform results correctly
      it('getWorkspaceProfile("openclaw") returns openclawProfile', () => {
        expect(getWorkspaceProfile('openclaw')).toBe(openclawProfile);
      });

      it('getWorkspaceProfile("standalone") returns standaloneProfile', () => {
        expect(getWorkspaceProfile('standalone')).toBe(standaloneProfile);
      });

      it('getWorkspaceProfile("agents-standard") returns agentsStandardProfile', () => {
        expect(getWorkspaceProfile('agents-standard')).toBe(agentsStandardProfile);
      });
    });
    ```

    **Section: PORT-03 activate() exposes profile on ActivateResult**

    ```typescript
    describe('PORT-03: activate() returns correct workspace profile', () => {
      let tmpDir: string;

      beforeEach(() => {
        tmpDir = mkdtempSync(join(tmpdir(), 'careagent-wiring-profile-'));
        createTestWorkspace(tmpDir);
      });

      afterEach(() => {
        rmSync(tmpDir, { recursive: true, force: true });
      });

      it('activate() returns standaloneProfile on ActivateResult', () => {
        const result = activate(tmpDir);
        expect(result.profile).toBeDefined();
        expect(result.profile.platform).toBe('standalone');
        expect(result.profile.files).toHaveLength(0);
      });
    });
    ```

    **Section: PORT-03 supplementWorkspaceFiles respects profile** (import supplementWorkspaceFiles and test each profile)

    ```typescript
    import { supplementWorkspaceFiles } from '../../src/onboarding/workspace-writer.js';
    ```

    ```typescript
    describe('PORT-03: supplementWorkspaceFiles respects profile selection', () => {
      let tmpDir: string;
      let mockCans: CANSDocument;  // Use the cans from createTestWorkspace or build minimal one

      beforeEach(() => {
        tmpDir = mkdtempSync(join(tmpdir(), 'careagent-profile-supplement-'));
        // Get a valid CANSDocument for supplementation
        createTestWorkspace(tmpDir);
        // Read back the CANS.md to get the parsed document
        // OR: construct a minimal CANSDocument inline matching the schema
      });

      afterEach(() => {
        rmSync(tmpDir, { recursive: true, force: true });
      });

      it('openclawProfile supplements SOUL.md, AGENTS.md, USER.md', () => {
        // Use the cans document and call supplementWorkspaceFiles with openclawProfile
        // Assert all three files exist
      });

      it('standaloneProfile supplements zero files', () => {
        const supplemented = supplementWorkspaceFiles(tmpDir, mockCans, 'Test philosophy', standaloneProfile);
        expect(supplemented).toHaveLength(0);
        expect(existsSync(join(tmpDir, 'SOUL.md'))).toBe(false);
      });

      it('agentsStandardProfile supplements only AGENTS.md', () => {
        const supplemented = supplementWorkspaceFiles(tmpDir, mockCans, 'Test philosophy', agentsStandardProfile);
        expect(supplemented).toEqual(['AGENTS.md']);
        expect(existsSync(join(tmpDir, 'AGENTS.md'))).toBe(true);
        expect(existsSync(join(tmpDir, 'SOUL.md'))).toBe(false);
        expect(existsSync(join(tmpDir, 'USER.md'))).toBe(false);
      });
    });
    ```

    To construct the mock CANSDocument, use the `activation` result from `activate(tmpDir)` (which returns `activation.document` when active), OR use the fixture data from `createTestWorkspace`. Read the existing test patterns in `test/unit/onboarding/workspace-writer.test.ts` to see how CANSDocument objects are constructed for tests.

    IMPORTANT: Do not modify existing tests in the file. Only append new describe blocks. Ensure all new imports are compatible with existing imports (no duplicates).
  </action>
  <verify>
    Run `npx vitest run test/integration/production-wiring.test.ts` — all existing tests plus new PORT-03 tests must pass. Then run `npx vitest run` for the full suite to confirm zero regressions.
  </verify>
  <done>
    - PORT-03 section added to production-wiring.test.ts with tests covering:
      1. getWorkspaceProfile maps all three platform strings correctly
      2. activate() returns the correct profile on ActivateResult
      3. supplementWorkspaceFiles writes correct files for each profile (openclaw: 3 files, standalone: 0 files, agents-standard: 1 file)
    - All 706+ tests pass with the new tests added
  </done>
</task>

</tasks>

<verification>
1. `npx vitest run` — all tests pass (706+ existing plus new PORT-03 tests)
2. `grep -n 'getWorkspaceProfile' src/entry/openclaw.ts` — confirms the function is called
3. `grep -n 'getWorkspaceProfile' src/entry/standalone.ts` — confirms the function is called
4. `grep -n 'profile' src/cli/commands.ts` — confirms profile parameter added and forwarded
5. `grep -n 'PORT-03' test/integration/production-wiring.test.ts` — confirms integration tests exist
</verification>

<success_criteria>
- detectPlatform() result flows through getWorkspaceProfile() in both entry points
- The resolved profile reaches runInitCommand() via registerCLI() in the openclaw path
- standalone ActivateResult exposes the profile for programmatic callers
- Integration tests prove all three profiles (openclaw, standalone, agents-standard) produce correct supplementation behavior
- All existing tests pass with zero regressions
</success_criteria>

<output>
After completion, create `.planning/phases/08-workspace-profile-selection-wiring/08-01-SUMMARY.md`
</output>
