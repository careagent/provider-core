# Phase 02.1: Architectural Alignment - Research

**Researched:** 2026-02-19
**Domain:** TypeScript codebase restructuring, TypeBox schema evolution, module interface design
**Confidence:** HIGH

## Summary

Phase 02.1 is a structural refactoring phase that bridges the gap between the current codebase (built incrementally across Phases 1 and 2) and the target architecture documented in the README. The codebase currently has 388 passing tests, zero runtime dependencies, and a well-established adapter pattern. The primary work is: (1) cleaning up legacy shim directories, (2) creating stub modules for four missing directories (hardening/, credentials/, neuron/, protocol/), (3) expanding the CANS TypeBox schema to include neuron registration, consent configuration, and clinical skill gating fields the README promises, and (4) updating the README to reflect the actual proven architecture (adapters/, entry/, cli/ exist but are not documented).

This is a preparatory phase -- it moves no existing behavior. It creates interfaces and stubs that Phase 3 (Hardening) and later phases will implement. The primary risk is breaking existing tests or import paths during directory restructuring. The primary reward is that Phase 3 can start from a clean, README-aligned codebase with well-defined module interfaces.

**Primary recommendation:** Restructure in small, test-verifiable steps. Never move a file and change its contents in the same step. Run the full 388-test suite after every structural change.

## Standard Stack

### Core (already locked by Phases 1-2)
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| TypeScript | ~5.7.0 | Language | Already configured with strict, ES2023, NodeNext |
| @sinclair/typebox | ~0.34.0 | Schema validation | Already used for CANSSchema, AuditEntrySchema |
| vitest | ~4.0.0 | Testing | Already configured, 388 tests |
| tsdown | ~0.20.0 | Build/bundle | Already configured with 4 entry points |
| yaml | ^2.8.2 | YAML parse/stringify | Vendored through src/vendor/yaml/index.ts |

### No New Dependencies Required

This phase requires **zero new dependencies**. All work is structural reorganization, TypeBox schema additions (TypeBox is already installed), and interface definitions using pure TypeScript. The zero-runtime-dependency constraint is maintained trivially.

## Architecture Patterns

### Current Project Structure (what exists)
```
src/
├── index.ts              # Re-exports entry/openclaw.ts default
├── activation/           # CANS parsing, validation, activation gate
│   ├── cans-integrity.ts
│   ├── cans-parser.ts
│   ├── cans-schema.ts
│   └── gate.ts
├── adapter/              # DEPRECATED shim — re-exports from adapters/
│   ├── openclaw-adapter.ts  # re-exports adapters/openclaw/index.ts
│   └── types.ts             # re-exports adapters/types.ts
├── adapters/             # CANONICAL — multi-platform adapter layer
│   ├── detect.ts
│   ├── index.ts
│   ├── openclaw/index.ts
│   ├── standalone/index.ts
│   └── types.ts
├── audit/                # Append-only JSONL with hash chaining
│   ├── entry-schema.ts
│   ├── integrity-service.ts
│   ├── pipeline.ts
│   └── writer.ts
├── cli/                  # CLI commands (init, status)
│   ├── commands.ts
│   ├── init-command.ts
│   ├── io.ts
│   ├── prompts.ts
│   └── status-command.ts
├── entry/                # Platform-specific entry points
│   ├── core.ts
│   ├── openclaw.ts
│   └── standalone.ts
├── onboarding/           # Interview engine and CANS generation
│   ├── cans-generator.ts
│   ├── defaults.ts
│   ├── engine.ts
│   ├── review.ts
│   ├── stages.ts
│   ├── workspace-content.ts
│   ├── workspace-profiles.ts
│   └── workspace-writer.ts
├── types/                # Shared type re-exports
│   ├── cans.ts           # re-exports from activation/cans-schema.ts
│   └── index.ts          # re-exports from adapter/types.ts
└── vendor/               # Vendored yaml
    └── yaml/index.ts
```

### Target Project Structure (README-aligned + proven abstractions)
```
src/
├── index.ts              # Plugin entry point — register(api)
├── activation/           # CANS.md parsing, validation, activation logic  [EXISTS]
├── adapters/             # Multi-platform adapter layer                    [EXISTS, not in README]
├── audit/                # AUDIT.log append-only logging                  [EXISTS]
├── cli/                  # CLI commands (init, status)                    [EXISTS, not in README]
├── credentials/          # Credential validation against CANS.md         [STUB NEEDED]
├── entry/                # Platform-specific entry points                 [EXISTS, not in README]
├── hardening/            # Six-layer hardening implementation            [STUB NEEDED]
├── neuron/               # Neuron registration and communication         [STUB NEEDED]
├── onboarding/           # careagent init interview and CANS generation  [EXISTS]
├── protocol/             # Cross-installation channel (server role)      [STUB NEEDED]
└── vendor/               # Vendored dependencies                         [EXISTS, not in README]
```

### Pattern 1: Deprecation Shim Removal

**What:** The `src/adapter/` (singular) and `src/types/` directories are backward-compatibility shims. They re-export from the canonical `src/adapters/` (plural) and `src/activation/cans-schema.ts` locations.

**Current state:** Only two source files still import from the old path:
- `src/audit/integrity-service.ts` imports `ServiceConfig` from `../adapter/types.js`
- `src/cli/commands.ts` imports `CareAgentPluginAPI` from `../adapter/types.js`

One test file imports from the old path:
- `test/unit/adapter/openclaw-adapter.test.ts` imports from `../../../src/adapter/openclaw-adapter.js`

**What to do:**
1. Update the two source imports to use `../adapters/types.js`
2. Update the test import to use `../../../src/adapters/openclaw/index.js`
3. Move the test file from `test/unit/adapter/` to `test/unit/adapters/openclaw/`
4. Delete `src/adapter/` directory (it will be empty after shim removal)
5. Delete `src/types/` directory (its re-exports are consumed by `src/entry/core.ts`, which should import directly)
6. Run tests after each step

### Pattern 2: Module Interface Stubs

**What:** Create stub modules with only exported interfaces/types and placeholder implementations that throw "not yet implemented" errors. The stubs define the contracts that later phases implement.

**When to use:** For hardening/, credentials/, neuron/, protocol/ -- these modules don't exist yet but Phase 3+ will need them.

**Example:**
```typescript
// src/hardening/index.ts
export type { HardeningEngine, HardeningLayerResult } from './types.js';
export { createHardeningEngine } from './engine.js';

// src/hardening/types.ts
import type { CANSDocument } from '../activation/cans-schema.js';
import type { PlatformAdapter } from '../adapters/types.js';
import type { AuditPipeline } from '../audit/pipeline.js';

/** Result from a single hardening layer check. */
export interface HardeningLayerResult {
  layer: string;
  allowed: boolean;
  reason?: string;
}

/** Configuration for the hardening engine. */
export interface HardeningConfig {
  cans: CANSDocument;
  adapter: PlatformAdapter;
  audit: AuditPipeline;
}

/** The hardening engine orchestrates all six layers. */
export interface HardeningEngine {
  /** Initialize all hardening layers. */
  activate(config: HardeningConfig): void;
  /** Check a tool call against all layers. */
  check(toolName: string, params?: Record<string, unknown>): HardeningLayerResult;
}

// src/hardening/engine.ts
import type { HardeningEngine, HardeningConfig, HardeningLayerResult } from './types.js';

export function createHardeningEngine(): HardeningEngine {
  return {
    activate(_config: HardeningConfig): void {
      throw new Error('Hardening engine not yet implemented (Phase 3)');
    },
    check(_toolName: string, _params?: Record<string, unknown>): HardeningLayerResult {
      throw new Error('Hardening engine not yet implemented (Phase 3)');
    },
  };
}
```

### Pattern 3: TypeBox Schema Extension (Backward Compatible)

**What:** Add new optional fields to the CANS schema so existing CANS.md files continue to validate while new fields are available for future phases.

**When to use:** For neuron registration, consent expansion, and clinical skill gating fields.

**Example:**
```typescript
// Adding neuron config to CANS schema — all Optional to maintain backward compat
export const NeuronConfigSchema = Type.Optional(Type.Object({
  endpoint: Type.String({ description: 'Neuron server URL' }),
  registration_id: Type.Optional(Type.String()),
  auto_register: Type.Optional(Type.Boolean({ default: true })),
}));

// Adding to CANSSchema:
export const CANSSchema = Type.Object({
  // ... existing fields ...
  neuron: Type.Optional(NeuronConfigSchema),
  skills: Type.Optional(SkillGatingSchema),
});
```

**Critical:** All new top-level fields MUST be `Type.Optional()`. This ensures the 388 existing tests continue to pass and all existing CANS.md fixtures remain valid.

### Pattern 4: README Bidirectional Sync

**What:** Update the README to document directories that exist but are missing from the Repository Structure section, while keeping future modules (hardening, credentials, neuron, protocol) listed since they now have stubs.

**When to use:** After structural changes are complete and tests pass.

### Anti-Patterns to Avoid

- **Moving files and changing their contents simultaneously:** Separate structural moves from content changes. A file move is a rename; content changes are edits. Do them in separate commits so git can track renames and tests can catch breakage at each step.

- **Creating "facade" modules that just re-export:** The old `adapter/` and `types/` shim directories are exactly this anti-pattern. Don't create new ones. Each module should have its own types co-located.

- **Making new schema fields required:** Any new field in CANSSchema that is required will break every existing test fixture and every existing CANS.md file. All new fields must be `Type.Optional()`.

- **Creating deep implementation in stubs:** Stubs should have only interfaces, types, and factory functions that throw. If you find yourself writing business logic in this phase, stop -- that belongs in Phase 3+.

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Schema backward compatibility | Manual version checking | TypeBox `Type.Optional()` | TypeBox validates gracefully when optional fields are missing |
| Import path updates | Find-and-replace | TypeScript compiler errors (`tsc --noEmit`) | Compiler catches every broken import; manual grep misses dynamic imports |
| Test migration validation | Manual test counting | `vitest run` count check (must remain 388) | Automated regression gate |

**Key insight:** TypeScript's strict mode + the existing 388-test suite ARE the safety net for this restructuring. Run `tsc --noEmit` and `vitest run` after every file move.

## Common Pitfalls

### Pitfall 1: Breaking the Build Entry Points
**What goes wrong:** Moving files that are referenced in `tsdown.config.ts` `entry` array or `package.json` `exports` breaks the build and all downstream consumers.
**Why it happens:** tsdown entry points must match actual file paths exactly.
**How to avoid:** Check `tsdown.config.ts` entry array and `package.json` exports map before moving any file in `src/entry/`. These four entry points (`src/index.ts`, `src/entry/openclaw.ts`, `src/entry/standalone.ts`, `src/entry/core.ts`) must NOT be moved.
**Warning signs:** `pnpm build` fails.

### Pitfall 2: Circular Dependencies in Stub Modules
**What goes wrong:** New stub modules import from existing modules that will later import from the stubs, creating circular dependency.
**Why it happens:** hardening/ needs CANSDocument from activation/; activation/ might later need HardeningResult. If both import each other, Node.js ESM can produce undefined imports.
**How to avoid:** Stub modules should import types from existing modules. Existing modules should NOT import from stubs in this phase. If a future phase needs activation/ to reference hardening/, that import is added in that future phase.
**Warning signs:** `undefined` values when importing, test failures that mention "Cannot read properties of undefined."

### Pitfall 3: TypeBox Schema Changes Breaking Validation
**What goes wrong:** Adding a required field to CANSSchema causes `Value.Check(CANSSchema, existingData)` to return false for all existing CANS.md files and test fixtures.
**Why it happens:** TypeBox strict object validation rejects extra or missing required fields.
**How to avoid:** All new schema fields must be `Type.Optional()`. Add a schema version field check if needed for migration later.
**Warning signs:** `cans-schema.test.ts` tests fail; `gate.test.ts` tests fail; `valid-cans-data.ts` fixture fails.

### Pitfall 4: Orphaned Test Files After Directory Moves
**What goes wrong:** Tests in `test/unit/adapter/` reference the old source path. If the source directory is deleted but the test file is not updated, the test imports a nonexistent module.
**Why it happens:** Test files have their own import paths separate from source import chains.
**How to avoid:** For every source file moved or deleted, grep for test files that import from that path. Update test imports in the same step.
**Warning signs:** `vitest run` fails with "Cannot find module" errors.

### Pitfall 5: Losing `CareAgentPluginAPI` Backward Compatibility
**What goes wrong:** Removing `src/adapter/types.ts` without preserving the `CareAgentPluginAPI` type alias somewhere accessible.
**Why it happens:** `CareAgentPluginAPI` is the deprecated name; `PlatformAdapter` is the current name. Both are currently exported from `src/adapters/types.ts` (the canonical location). As long as that file is preserved, the alias is safe.
**How to avoid:** Verify `CareAgentPluginAPI` is exported from `src/adapters/types.ts` before deleting `src/adapter/types.ts`. It already is (line 89: `export type CareAgentPluginAPI = PlatformAdapter;`).
**Warning signs:** TypeScript compilation errors referencing `CareAgentPluginAPI`.

### Pitfall 6: README Drift from Implementation
**What goes wrong:** README says `src/hardening/` exists and is fully implemented when it is just stubs.
**Why it happens:** Copying the README's future-looking architecture verbatim without noting what is stubbed vs. implemented.
**How to avoid:** README should clearly mark modules that are stubs/interfaces-only vs. fully implemented. Use language like "interface defined, implementation in Phase 3."
**Warning signs:** A developer reads the README and expects full hardening to work.

## Code Examples

### TypeBox Optional Schema Extension (verified pattern from existing codebase)
```typescript
// Source: src/activation/cans-schema.ts (existing pattern — clinical_voice is Optional)
export const CANSSchema = Type.Object({
  version: Type.String({ description: 'CANS.md schema version' }),
  provider: ProviderSchema,
  scope: ScopeSchema,
  autonomy: AutonomySchema,
  hardening: HardeningSchema,
  consent: ConsentSchema,
  clinical_voice: Type.Optional(ClinicalVoiceSchema),  // <-- existing Optional pattern
  // New fields follow same pattern:
  neuron: Type.Optional(NeuronConfigSchema),
  skills: Type.Optional(SkillGatingSchema),
});
```

### Module Index Re-export Pattern (verified from existing codebase)
```typescript
// Source: src/adapters/index.ts (existing pattern)
export type {
  PlatformAdapter,
  CareAgentPluginAPI,
  ToolCallEvent,
  ToolCallResult,
  ToolCallHandler,
  BootstrapContext,
  BootstrapHandler,
  CliCommandConfig,
  ServiceConfig,
  SlashCommandConfig,
} from './types.js';

export { createAdapter } from './openclaw/index.js';
export { createStandaloneAdapter } from './standalone/index.js';
export { detectPlatform } from './detect.js';
export type { DetectedPlatform } from './detect.js';
```

### Stub Module Interface Pattern (derived from existing conventions)
```typescript
// src/credentials/types.ts — interface-only, no implementation
import type { CANSDocument } from '../activation/cans-schema.js';

/** Result of a credential validation check. */
export interface CredentialCheckResult {
  valid: boolean;
  provider: string;
  licenseType: string;
  specialty: string;
  missingCredentials?: string[];
  reason?: string;
}

/** Validates provider credentials from CANS.md. */
export interface CredentialValidator {
  /** Check whether credentials are sufficient for a given action. */
  check(cans: CANSDocument, action: string): CredentialCheckResult;
}
```

### Fixing Stale Imports (two files need updating)
```typescript
// src/audit/integrity-service.ts — BEFORE:
import type { ServiceConfig } from '../adapter/types.js';
// AFTER:
import type { ServiceConfig } from '../adapters/types.js';

// src/cli/commands.ts — BEFORE:
import type { CareAgentPluginAPI } from '../adapter/types.js';
// AFTER:
import type { PlatformAdapter } from '../adapters/types.js';
// Also update function signature:
export function registerCLI(adapter: PlatformAdapter, ...): void {
```

## CANS Schema Expansion Plan

### Fields the README promises but the schema doesn't have:

| Field | README Reference | Proposed Schema | Why Optional |
|-------|-----------------|-----------------|--------------|
| `neuron` | "Neuron registration -- the Neuron endpoint this CareAgent registers with" | `Type.Optional(Type.Object({ endpoint, registration_id, auto_register }))` | Neuron integration is Phase 5+ |
| `skills` | "Clinical skill gating rules" | `Type.Optional(Type.Object({ gating_rules: Type.Array(...) }))` | Skill loading is Phase 4 |

### Fields the README mentions within consent but are already covered:

The README says CANS.md includes "Consent configuration -- cross-installation communication permissions." The current schema has a `ConsentSchema` with `hipaa_warning_acknowledged`, `synthetic_data_only`, and `audit_consent`. Cross-installation consent (for Axon protocol) should be added as optional sub-fields within consent or as a separate optional top-level section.

### Proposed Schema Additions:

```typescript
// Neuron configuration
export const NeuronConfigSchema = Type.Object({
  endpoint: Type.String({ description: 'Neuron server URL' }),
  registration_id: Type.Optional(Type.String({ description: 'Registration ID assigned by Neuron' })),
  auto_register: Type.Optional(Type.Boolean({ description: 'Register on Gateway startup' })),
});

// Skill gating rules
export const SkillGatingRuleSchema = Type.Object({
  skill_id: Type.String({ description: 'Skill package identifier' }),
  requires_license: Type.Optional(Type.Array(Type.String())),
  requires_specialty: Type.Optional(Type.Array(Type.String())),
  requires_privilege: Type.Optional(Type.Array(Type.String())),
});

export const SkillGatingSchema = Type.Object({
  rules: Type.Array(SkillGatingRuleSchema, { description: 'Per-skill credential requirements' }),
});

// Cross-installation consent (addition to existing ConsentSchema)
export const CrossInstallationConsentSchema = Type.Object({
  allow_inbound: Type.Boolean({ description: 'Accept patient CareAgent connections' }),
  allow_outbound: Type.Boolean({ description: 'Initiate connections to patient CareAgents' }),
  require_neuron_verification: Type.Optional(Type.Boolean({ description: 'Require Neuron-verified identity' })),
});

// Updated CANSSchema
export const CANSSchema = Type.Object({
  version: Type.String({ description: 'CANS.md schema version' }),
  provider: ProviderSchema,
  scope: ScopeSchema,
  autonomy: AutonomySchema,
  hardening: HardeningSchema,
  consent: ConsentSchema,
  clinical_voice: Type.Optional(ClinicalVoiceSchema),
  // New optional sections:
  neuron: Type.Optional(NeuronConfigSchema),
  skills: Type.Optional(SkillGatingSchema),
  cross_installation: Type.Optional(CrossInstallationConsentSchema),
});
```

## Directory Cleanup Inventory

### To Remove (shim directories):
| Directory | Current Purpose | Files Still Importing From Here | Safe to Remove After |
|-----------|----------------|-------------------------------|---------------------|
| `src/adapter/` | Backward-compat re-export shims | `src/audit/integrity-service.ts`, `src/cli/commands.ts` | Updating those 2 imports |
| `src/types/` | Re-exports from activation/cans-schema + adapter/types | `src/entry/core.ts` via `../types/index.js` | Checking -- actually `src/entry/core.ts` imports directly from adapters and activation, so `types/` may be unused from source. Need to verify. |

### To Create (stub modules):
| Directory | Purpose | Files to Create | Interface Source |
|-----------|---------|-----------------|-----------------|
| `src/hardening/` | Six-layer hardening engine | `types.ts`, `engine.ts`, `index.ts` | README Hardening section + HARD-01..07 |
| `src/credentials/` | Credential validation | `types.ts`, `validator.ts`, `index.ts` | README Credentials section + SKIL-01 |
| `src/neuron/` | Neuron registration | `types.ts`, `client.ts`, `index.ts` | README Neuron section |
| `src/protocol/` | Cross-installation channel | `types.ts`, `server.ts`, `index.ts` | README Protocol section |

### To Keep (proven architecture, update README to include):
| Directory | In README? | Action |
|-----------|-----------|--------|
| `src/adapters/` | No | Add to README Repository Structure |
| `src/cli/` | No | Add to README Repository Structure |
| `src/entry/` | No | Add to README Repository Structure |
| `src/vendor/` | No | Add to README Repository Structure |
| `src/activation/` | Yes | Keep as-is |
| `src/audit/` | Yes | Keep as-is |
| `src/onboarding/` | Yes | Keep as-is |

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| `src/adapter/` (singular) | `src/adapters/` (plural) with platform dirs | Phase 2 (PORT-01..04) | Two source files still use old path |
| `CareAgentPluginAPI` type name | `PlatformAdapter` type name | Phase 2 (PORT-01) | Deprecated alias preserved |
| Types in `src/types/` | Types co-located with modules | Phase 2 | `src/types/` now purely re-exports |

## Test Strategy

### Regression Gate
- 388 tests must continue passing after every structural change
- `pnpm build` must succeed after every structural change
- `tsc --noEmit` must pass after every structural change

### New Tests for This Phase
| What to Test | Test Type | Estimated Count |
|-------------|-----------|-----------------|
| New CANS schema fields (neuron, skills, cross_installation) validate when present | Unit | 8-12 |
| New CANS schema fields are optional (existing fixtures still pass) | Unit | 3-5 |
| Stub module exports resolve without error | Unit | 4-8 |
| Stub module functions throw "not implemented" | Unit | 4-8 |
| Build produces all expected entry points | Integration | 1-2 |

## Execution Order Recommendation

The planner should structure tasks in this order to minimize risk:

1. **Fix stale imports** (2 source files + 1 test file) -- zero-risk, immediate cleanup
2. **Remove deprecated shim directories** (`src/adapter/`, `src/types/`) -- depends on step 1
3. **Create stub modules** (hardening/, credentials/, neuron/, protocol/) -- independent of steps 1-2
4. **Expand CANS schema** with optional fields -- independent of steps 1-3
5. **Update entry/core.ts re-exports** to include new stub module types -- depends on step 3
6. **Update README** Repository Structure section -- depends on steps 2-4
7. **Update tsdown.config.ts** if new entry points needed -- likely no change needed
8. **Final verification** -- all 388+ tests pass, build succeeds, typecheck passes

Steps 1-2 are sequential. Steps 3-4 are parallelizable. Steps 5-6 depend on 3-4.

## Open Questions

1. **Should `src/entry/core.ts` export types from the new stub modules?**
   - What we know: `core.ts` currently exports adapter types, activation types, audit pipeline, and workspace profiles. It is the "pure re-export" entry point.
   - What's unclear: Should it also export hardening/credentials/neuron/protocol types so consumers can type-check against them without importing from deep paths?
   - Recommendation: YES -- export the interface types from stubs through `core.ts`. This is consistent with the existing pattern and gives downstream code a stable import surface.

2. **Should the test directory mirror the source directory structure?**
   - What we know: Currently `test/unit/adapter/` exists for the old shim. `test/unit/adapters/` exists for the new adapter layer. Both exist.
   - What's unclear: Should `test/unit/adapter/` be removed/merged, and should new `test/unit/hardening/`, `test/unit/credentials/` directories be created for stub tests?
   - Recommendation: YES -- remove `test/unit/adapter/` (move its one test to `test/unit/adapters/`), and create directories for stub module tests to maintain the 1:1 source-test mirror.

3. **How much interface detail for stub modules?**
   - What we know: Phase 3 (Hardening) has 7 specific requirements (HARD-01..07). Phase 4 (Skills) has 7 requirements (SKIL-01..07).
   - What's unclear: Should stubs define minimal interfaces (just the factory function signature) or detailed interfaces covering every requirement?
   - Recommendation: Define interfaces that cover the major contracts (what methods exist, what types they accept/return) but don't try to pre-design every internal detail. Phase 3 planning will refine. Focus on: what does the hardening module export that `entry/openclaw.ts` needs to call?

## Sources

### Primary (HIGH confidence)
- Direct codebase examination of all 31 source files and 26 test files
- `package.json` -- dependencies, exports, scripts (verified by running tests)
- `tsconfig.json` -- compiler options (verified by examining build output)
- `tsdown.config.ts` -- build entry points (verified by examining configuration)
- `test/` -- all 388 tests verified passing via `npx vitest run`

### Secondary (HIGH confidence)
- `.planning/REQUIREMENTS.md` -- HARD-01..07, SKIL-01..07 requirements define what stub interfaces need
- `.planning/ROADMAP.md` -- Phase dependency chain (Phase 2.1 between Phase 2 and Phase 3)
- `.planning/STATE.md` -- Key decisions from Phases 1-2 that constrain this phase
- `README.md` -- Target architecture and CANS.md field descriptions

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH -- no new dependencies; everything is already in the codebase
- Architecture: HIGH -- restructuring is well-defined; gap analysis is complete from direct file inspection
- Pitfalls: HIGH -- derived from direct observation of import chains, test structure, and TypeBox validation behavior
- CANS schema expansion: MEDIUM -- schema field names and structure are inferred from README prose; may need refinement during Phase 3-5 planning
- Stub module interfaces: MEDIUM -- interfaces are informed by requirements but Phase 3 planning will refine them

**Research date:** 2026-02-19
**Valid until:** 2026-03-19 (stable -- this is internal restructuring, not dependent on external ecosystem changes)
