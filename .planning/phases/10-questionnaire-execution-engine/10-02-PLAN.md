---
phase: 10-questionnaire-execution-engine
plan: 02
type: execute
wave: 2
depends_on:
  - "10-01"
files_modified:
  - src/onboarding/engine.ts
  - src/onboarding/stages.ts
  - src/onboarding/questionnaire-stage.ts
  - src/onboarding/defaults.ts
autonomous: true
requirements:
  - ONBD-01
  - ONBD-02
  - ONBD-03
  - ONBD-07

must_haves:
  truths:
    - "Onboarding asks provider name as the first question after welcome"
    - "Onboarding asks provider type selected from Axon's 49 categories as the second question"
    - "After type selection, the matching questionnaire is fetched from Axon and its questions are presented dynamically"
    - "When a stub questionnaire is fetched (empty questions array), onboarding blocks with a message and suggests types that have full questionnaires"
  artifacts:
    - path: "src/onboarding/questionnaire-stage.ts"
      provides: "Dynamic questionnaire execution stage using InterviewIO and questionnaire-runner"
      exports: ["questionnaireStage"]
      min_lines: 60
    - path: "src/onboarding/engine.ts"
      provides: "Refactored v2.0 interview engine with AxonClient dependency injection"
      exports: ["runInterview", "InterviewStage", "InterviewState", "InterviewResult"]
      min_lines: 80
    - path: "src/onboarding/stages.ts"
      provides: "Updated stages with v2.0 name-first identity and Axon-based type selection"
      min_lines: 100
  key_links:
    - from: "src/onboarding/engine.ts"
      to: "src/axon/client.ts"
      via: "AxonClient dependency injection in runInterview"
      pattern: "AxonClient"
    - from: "src/onboarding/questionnaire-stage.ts"
      to: "src/onboarding/questionnaire-runner.ts"
      via: "imports evaluateShowWhen, collectGrantedActions, getVisibleQuestions"
      pattern: "import.*questionnaire-runner"
    - from: "src/onboarding/stages.ts"
      to: "src/axon/types.ts"
      via: "uses AxonProviderType for type selection menu"
      pattern: "AxonProviderType"
---

<objective>
Refactor the onboarding flow from v1.0's hardcoded interview stages to v2.0's dynamic questionnaire-driven flow: name first, provider type from Axon taxonomy second, then dynamically run the fetched questionnaire.

Purpose: This is the central wiring that transforms CareAgent onboarding from a static interview into a questionnaire engine that adapts to each provider type.

Output: Refactored `engine.ts`, updated `stages.ts`, new `questionnaire-stage.ts`, and updated `defaults.ts`.
</objective>

<execution_context>
@/Users/medomatic/.claude/get-shit-done/workflows/execute-plan.md
@/Users/medomatic/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-axon-client-layer/09-01-SUMMARY.md
@.planning/phases/10-questionnaire-execution-engine/10-01-SUMMARY.md

@src/onboarding/engine.ts
@src/onboarding/stages.ts
@src/onboarding/review.ts
@src/onboarding/cans-generator.ts
@src/onboarding/defaults.ts
@src/cli/init-command.ts
@src/cli/io.ts
@src/cli/prompts.ts
@src/axon/types.ts
@src/axon/client.ts
@src/activation/cans-schema.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create questionnaire-stage.ts and update stages.ts</name>
  <files>
    src/onboarding/questionnaire-stage.ts
    src/onboarding/stages.ts
  </files>
  <action>
**Create `src/onboarding/questionnaire-stage.ts`:**

This module runs an Axon questionnaire interactively via InterviewIO. It:
1. Iterates through questions in order
2. For each question, checks `evaluateShowWhen` — if false, skips it
3. For `boolean` questions: uses `io.confirm(question.text)` and records `'yes'` or `'no'` as the answer
4. For `single_select` questions: uses `io.select(question.text, question.options.map(o => o.label))` and records `options[selectedIndex].value` as the answer
5. Accumulates answers in a `QuestionnaireAnswers` record
6. After all questions, calls `collectGrantedActions(questions, answers)` to get the granted action IDs
7. Returns `{ answers: QuestionnaireAnswers, grantedActions: string[] }`

```typescript
import type { InterviewIO } from '../cli/io.js';
import type { AxonQuestion } from '../axon/types.js';
import type { QuestionnaireAnswers } from './questionnaire-runner.js';
import { evaluateShowWhen, collectGrantedActions } from './questionnaire-runner.js';

export interface QuestionnaireResult {
  answers: QuestionnaireAnswers;
  grantedActions: string[];
}

/**
 * Run an Axon questionnaire interactively, evaluating show_when conditions
 * in real time as answers are collected. Returns answers and granted actions.
 */
export async function runQuestionnaire(
  questions: AxonQuestion[],
  io: InterviewIO,
): Promise<QuestionnaireResult>
```

Implementation notes:
- For boolean questions, display the question text via `io.confirm(q.text)`, store `'yes'` or `'no'`
- For single_select questions, display via `io.select(q.text, q.options!.map(o => \`\${o.label}\${o.description ? ' — ' + o.description : ''}\`))`, record `q.options![selectedIndex].value`
- After each answer is recorded, subsequent questions re-evaluate show_when against the growing answers map
- Required questions that are visible MUST be answered (boolean always has an answer via confirm; select always has an answer via select)

**Update `src/onboarding/stages.ts`:**

1. **Modify `identityStage`** (ONBD-01): Keep the provider name question. REMOVE the NPI question from identity stage. The stage now ONLY asks for the provider's name (first question after welcome). Update return to advance to a new `PROVIDER_TYPE` stage instead of `CREDENTIALS`.

2. **Add `providerTypeStage`** (ONBD-02): New stage that:
   - Receives `AxonProviderType[]` from state (populated by the engine before calling this stage)
   - Groups provider types by category and displays them as a flat select menu: `io.select('Select your provider type:', types.map(t => t.display_name))`
   - Records the selected provider type ID in state data
   - Advances to `QUESTIONNAIRE` stage

3. **Add `stubBlockingStage`** (ONBD-07): New stage that:
   - Displays a blocking message: `"The questionnaire for [display_name] is not yet available."`
   - Fetches the provider types list and filters to those whose questionnaire has `questions.length > 0` (this list will be passed in state)
   - Suggests available types: `"The following types have full questionnaires: [list]"`
   - Displays: `"Please select a different provider type or check back later."`
   - Returns to the PROVIDER_TYPE stage to let the user re-select

Note: Import `AxonProviderType` from `'../axon/types.js'` using `import type`.

Do NOT modify welcomeStage, philosophyStage, voiceStage, autonomyStage, or consentStage. The credentialsStage, specialtyStage, and scopeStage will no longer be referenced from the engine (they stay in the file for now but are unused in v2.0 flow — the questionnaire replaces them).
  </action>
  <verify>`pnpm typecheck` passes with no new errors in the modified files.</verify>
  <done>questionnaire-stage.ts created with runQuestionnaire function. stages.ts has identityStage (name-only), providerTypeStage (Axon type select), stubBlockingStage (block + suggest).</done>
</task>

<task type="auto">
  <name>Task 2: Refactor onboarding engine for v2.0 flow</name>
  <files>
    src/onboarding/engine.ts
    src/onboarding/defaults.ts
    src/cli/init-command.ts
  </files>
  <action>
**Refactor `src/onboarding/engine.ts`:**

1. Add new stages to `InterviewStage` enum:
   - `PROVIDER_TYPE = 'PROVIDER_TYPE'` (after IDENTITY)
   - `QUESTIONNAIRE = 'QUESTIONNAIRE'` (after PROVIDER_TYPE)
   Keep existing stages for backward compatibility but the v2.0 sequence will not use CREDENTIALS, SPECIALTY, or SCOPE.

2. Update `InterviewState` to include:
   - `providerTypes?: AxonProviderType[]` — cached provider type list from Axon
   - `selectedProviderTypeId?: string` — the selected provider type ID
   - `selectedProviderTypeDisplayName?: string` — display name for messages
   - `questionnaire?: AxonQuestionnaire` — fetched questionnaire
   - `questionnaireAnswers?: QuestionnaireAnswers` — answers from questionnaire
   - `grantedActions?: string[]` — action IDs granted by questionnaire
   - `availableTypes?: string[]` — display names of types with full questionnaires (for stub blocking)

3. Update `InterviewResult` to include:
   - `grantedActions: string[]` — for downstream CANS generation

4. Update `runInterview` signature to accept an `AxonClient`:
   ```typescript
   export async function runInterview(
     io: InterviewIO,
     axonClient: AxonClient,
   ): Promise<InterviewResult>
   ```

5. Implement the v2.0 stage sequence:
   ```
   WELCOME -> IDENTITY (name only) -> PROVIDER_TYPE (Axon select) ->
   [fetch questionnaire from Axon] ->
   [if stub: STUB_BLOCKING -> loop back to PROVIDER_TYPE] ->
   QUESTIONNAIRE (dynamic run) ->
   PHILOSOPHY -> VOICE -> AUTONOMY -> CONSENT -> COMPLETE
   ```

   Between PROVIDER_TYPE and QUESTIONNAIRE, the engine:
   a. Calls `axonClient.getProviderTypes()` to populate `state.providerTypes` before PROVIDER_TYPE stage (only once, cache in state)
   b. After type selection, calls `axonClient.getQuestionnaire(selectedId)` to fetch the questionnaire
   c. Checks if `questionnaire.questions.length === 0` — if yes, routes to stub blocking
   d. Stub blocking shows message and re-routes to PROVIDER_TYPE

   The QUESTIONNAIRE stage calls `runQuestionnaire(questionnaire.questions, io)` from `questionnaire-stage.ts` and stores results in state.

   After QUESTIONNAIRE completes, populate `state.data.scope.permitted_actions` from `grantedActions` and populate `state.data.provider.types` with `[selectedProviderTypeDisplayName]`.

6. Update STAGE_HANDLERS map to include the new stages. The engine orchestration logic (the loop) needs to handle the branching (stub blocking -> back to PROVIDER_TYPE).

   **Implementation approach:** Replace the simple `for` loop with a state-machine `while` loop:
   ```typescript
   while (state.stage !== InterviewStage.COMPLETE) {
     switch (state.stage) {
       case InterviewStage.WELCOME:
         state = await runSingleStage(InterviewStage.WELCOME, state, io);
         break;
       case InterviewStage.IDENTITY:
         state = await runSingleStage(InterviewStage.IDENTITY, state, io);
         // After identity, fetch provider types from Axon if not cached
         if (!state.providerTypes) {
           state.providerTypes = await axonClient.getProviderTypes();
         }
         break;
       case InterviewStage.PROVIDER_TYPE:
         state = await runSingleStage(InterviewStage.PROVIDER_TYPE, state, io);
         // After type selection, fetch questionnaire
         const questionnaire = await axonClient.getQuestionnaire(state.selectedProviderTypeId!);
         state.questionnaire = questionnaire;
         if (questionnaire.questions.length === 0) {
           // Stub — find available types (those with questions)
           // For now, filter cached providerTypes (we'll check questionnaires)
           // Show blocking message and loop back
           state.stage = InterviewStage.PROVIDER_TYPE; // after stub display
         }
         break;
       // ... remaining stages
     }
   }
   ```

   For the stub blocking flow: when an empty questionnaire is detected, display the blocking message directly in the engine loop (using `io.display()`), list the available types that have full questionnaires (this requires knowing which types have questionnaires — since checking all 49 would be expensive, use a simpler approach: display the selected type's display_name with a message that it's not yet available, and suggest the user try "Physician" which is known to have a full questionnaire per the requirements). Then set state.stage back to PROVIDER_TYPE.

**Update `src/onboarding/defaults.ts`:**
- No structural changes needed. The defaults still apply to philosophy, voice, autonomy, consent stages which remain unchanged.

**Update `src/cli/init-command.ts`:**
- Update `runInitCommand` to accept and pass `AxonClient` to `runInterview`:
  ```typescript
  export async function runInitCommand(
    io: InterviewIO,
    workspacePath: string,
    audit: AuditPipeline,
    axonClient: AxonClient,
    profile?: WorkspaceProfile,
  ): Promise<void>
  ```
- Pass `axonClient` to `runInterview(io, axonClient)`
- After review loop completes, if `result.grantedActions` is available, the scope.permitted_actions should already be populated in the data. No additional wiring needed since the engine sets it.

**Important:** The AxonClient is NOT created inside onboarding. It is injected from the entry point. The entry points (`openclaw.ts`, `standalone.ts`) will need to create the AxonClient and pass it through `registerCLI` -> `runInitCommand` -> `runInterview`. However, modifying entry points is a separate concern — for now, update the function signatures to ACCEPT AxonClient. The actual wiring of entry points will happen as a natural consequence (the TypeScript compiler will flag the missing argument).

For the entry point wiring: also update `src/cli/commands.ts` (`registerCLI`) to accept and forward `AxonClient`. Update `src/entry/openclaw.ts` and `src/entry/standalone.ts` to create an AxonClient (using `createAxonClient({ baseUrl: process.env.AXON_BASE_URL || 'http://localhost:9999' })`) and pass it through. This ensures the full chain is wired.
  </action>
  <verify>
- `pnpm typecheck` passes
- `pnpm vitest run test/unit/onboarding/engine.test.ts` — existing tests may need updates for new signature (update mock calls to pass a mock AxonClient)
  </verify>
  <done>
- engine.ts has v2.0 state machine with WELCOME -> IDENTITY -> PROVIDER_TYPE -> QUESTIONNAIRE -> PHILOSOPHY -> VOICE -> AUTONOMY -> CONSENT flow
- AxonClient injected through init-command -> engine
- Stub questionnaires block and suggest alternatives
- Entry points create and pass AxonClient
- Existing onboarding tests updated for new signatures
  </done>
</task>

</tasks>

<verification>
- `pnpm typecheck` — no type errors
- `pnpm vitest run test/unit/onboarding/` — existing onboarding tests pass (with signature updates)
- `pnpm test` — full test suite passes with zero regressions
- Manual trace: engine.ts WELCOME -> IDENTITY (name) -> PROVIDER_TYPE (Axon) -> fetch -> QUESTIONNAIRE -> PHILOSOPHY -> VOICE -> AUTONOMY -> CONSENT
</verification>

<success_criteria>
- Onboarding asks name first (ONBD-01)
- Onboarding presents Axon provider types for selection (ONBD-02)
- Questionnaire fetched from Axon after type selection (ONBD-03)
- Stub questionnaires block with helpful message (ONBD-07)
- AxonClient wired through the full chain from entry points to engine
- All existing tests pass with updated signatures
</success_criteria>

<output>
After completion, create `.planning/phases/10-questionnaire-execution-engine/10-02-SUMMARY.md`
</output>
