---
phase: 05-cans-continuous-improvement-and-integration
plan: 02
type: execute
wave: 2
depends_on:
  - 05-01
files_modified:
  - src/refinement/refinement-engine.ts
  - src/refinement/index.ts
  - src/cli/commands.ts
  - src/cli/proposals-command.ts
  - src/entry/openclaw.ts
  - src/entry/standalone.ts
  - src/entry/core.ts
  - test/unit/refinement/refinement-engine.test.ts
  - test/unit/refinement/proposals-command.test.ts
autonomous: true
requirements:
  - CANS-08
  - CANS-09
  - CANS-10

must_haves:
  truths:
    - "RefinementEngine composes observation store, pattern matcher, proposal generator, and proposal queue into a single API"
    - "Accepted proposals modify CANS.md via the existing parse/validate/write/hash-update chain"
    - "Scope field proposals are blocked at the applyProposal level as a third safety layer"
    - "Every proposal lifecycle event (proposed, accepted, rejected, deferred) is audit-logged"
    - "Provider can review proposals in batch via 'careagent proposals' CLI command with Accept/Reject/Defer actions"
    - "Refinement engine is wired into openclaw.ts and standalone.ts entry points"
  artifacts:
    - path: "src/refinement/refinement-engine.ts"
      provides: "Top-level orchestrator composing all refinement components"
      exports: ["createRefinementEngine", "RefinementEngine"]
    - path: "src/refinement/index.ts"
      provides: "Public API re-exports for the refinement module"
      exports: ["createRefinementEngine"]
    - path: "src/cli/proposals-command.ts"
      provides: "CLI handler for careagent proposals command with batch presentation"
      exports: ["runProposalsCommand"]
    - path: "src/entry/core.ts"
      provides: "Refinement types and factory re-exports"
      contains: "refinement"
  key_links:
    - from: "src/refinement/refinement-engine.ts"
      to: "src/activation/cans-integrity.ts"
      via: "updateKnownGoodHash after accepted proposal write"
      pattern: "updateKnownGoodHash"
    - from: "src/refinement/refinement-engine.ts"
      to: "src/audit/pipeline.ts"
      via: "AuditPipeline.log for every proposal lifecycle event"
      pattern: "audit\\.log.*cans_proposal"
    - from: "src/entry/openclaw.ts"
      to: "src/refinement/refinement-engine.ts"
      via: "createRefinementEngine() called after activation"
      pattern: "createRefinementEngine"
    - from: "src/cli/proposals-command.ts"
      to: "src/refinement/refinement-engine.ts"
      via: "Engine methods for proposal listing and resolution"
      pattern: "getPendingProposals|resolveProposal"
---

<objective>
Build the refinement engine orchestrator, wire CANS.md write-back with audit logging, create the CLI proposals command, and integrate refinement into all entry points.

Purpose: This plan completes the refinement subsystem by composing the foundational components (Plan 01) into a coherent engine, implementing the CANS.md modification chain for accepted proposals (with scope protection as a third safety layer), adding audit logging for every proposal lifecycle event, and providing the `careagent proposals` CLI command for batch review. Entry points are updated to create and expose the refinement engine.

Output: Complete refinement engine with CLI interface wired into all three entry points.
</objective>

<execution_context>
@/Users/medomatic/.claude/get-shit-done/workflows/execute-plan.md
@/Users/medomatic/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-cans-continuous-improvement-and-integration/05-RESEARCH.md
@.planning/phases/05-cans-continuous-improvement-and-integration/05-01-SUMMARY.md
@src/activation/cans-integrity.ts
@src/activation/cans-parser.ts
@src/activation/cans-schema.ts
@src/vendor/yaml/index.ts
@src/audit/pipeline.ts
@src/entry/openclaw.ts
@src/entry/standalone.ts
@src/entry/core.ts
@src/cli/commands.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create refinement engine orchestrator with CANS.md write-back and audit logging</name>
  <files>
    src/refinement/refinement-engine.ts
    src/refinement/index.ts
    test/unit/refinement/refinement-engine.test.ts
  </files>
  <action>
    Create `src/refinement/refinement-engine.ts`:

    Export `RefinementEngine` interface:
    - `observe(obs: Omit<Observation, 'timestamp' | 'session_id'>): void` — records a usage observation
    - `generateProposals(): Proposal[]` — detects divergence patterns and creates new proposals
    - `getPendingProposals(): Proposal[]` — returns pending + deferred proposals for presentation
    - `resolveProposal(proposalId: string, action: ProposalResolution): void` — accept/reject/defer a proposal
    - `getProposalById(id: string): Proposal | undefined` — lookup by ID

    Export `createRefinementEngine(config: { workspacePath: string; audit: AuditPipeline; sessionId: string }): RefinementEngine`:

    Implementation details:
    1. Instantiate `ObservationStore(config.workspacePath)` and `ProposalQueue(config.workspacePath)`
    2. `observe()`: Adds `timestamp: new Date().toISOString()` and `session_id: config.sessionId`, then calls `store.append(fullObs)`
    3. `generateProposals()`:
       - Call `store.query()` to get all observations
       - Call `queue.getPending()` to get existing proposals
       - Call `detectDivergences(observations, existingProposals)` from pattern-matcher
       - Call `generateProposals(divergences, config.sessionId)` from proposal-generator
       - For each new proposal: call `queue.add(proposal)`, then audit log:
         ```
         audit.log({
           action: 'cans_proposal_created',
           actor: 'system',
           outcome: 'allowed',
           details: { proposal_id, field_path, category, observation_count, evidence_summary }
         })
         ```
       - Return newly created proposals
    4. `getPendingProposals()`: Return `queue.getPending()`
    5. `resolveProposal(proposalId, action)`:
       - Call `queue.resolve(proposalId, action)`
       - If action is `'accept'`: call `applyProposal()` (see below)
       - Audit log the resolution:
         ```
         audit.log({
           action: `cans_proposal_${action}ed`,  // accepted, rejected, deferred
           actor: 'provider',
           outcome: 'allowed',
           action_state: action === 'accept' ? 'provider-approved' : action === 'reject' ? 'provider-rejected' : 'provider-modified',
           details: { proposal_id, field_path, current_value, proposed_value }
         })
         ```
         Note: For `deferred`, use action `cans_proposal_deferred` and action_state `provider-modified`.

    Implement `applyProposal(workspacePath: string, proposal: Proposal, audit: AuditPipeline): void` as an internal function:
    1. **CRITICAL safety check (defense layer 3):** `if (isScopeField(proposal.field_path)) throw new Error('SAFETY VIOLATION: Cannot modify scope fields')`
    2. Read CANS.md: `readFileSync(join(workspacePath, 'CANS.md'), 'utf-8')`
    3. Parse: `parseFrontmatter(raw)` from `src/activation/cans-parser.ts`
    4. Apply field change via dot-path navigation on `frontmatter` object. Implement a `setNestedValue(obj, dotPath, value)` helper that navigates dot-separated keys (e.g., `'clinical_voice.tone'` sets `obj.clinical_voice.tone`).
    5. Validate: `Value.Check(CANSSchema, frontmatter)` — if invalid, throw Error with `Value.Errors()` details
    6. Serialize: `stringifyYAML(frontmatter)` from vendor/yaml
    7. Reconstruct content: `` `---\n${yaml}---\n\n${body}` ``
    8. Write: `writeFileSync(cansPath, content, 'utf-8')`
    9. Update integrity hash: `updateKnownGoodHash(workspacePath, content)` from `src/activation/cans-integrity.ts`

    Create `src/refinement/index.ts`:
    - Re-export types: `Observation, Proposal, DivergencePattern, ObservationCategory, ProposalResolution` from types.ts
    - Re-export constants: `DEFAULT_DIVERGENCE_THRESHOLD, RESURFACE_THRESHOLD, SACROSANCT_FIELDS, isScopeField, CATEGORY_FIELDS` from types.ts
    - Re-export `ObservationStore` from observation-store.ts
    - Re-export `ProposalQueue` from proposal-queue.ts
    - Re-export `detectDivergences` from pattern-matcher.ts
    - Re-export `generateProposals as generateProposalsFromDivergences, generateDiffView` from proposal-generator.ts
    - Re-export `createRefinementEngine, RefinementEngine` from refinement-engine.ts

    Create unit tests in `test/unit/refinement/refinement-engine.test.ts`:
    - Test: observe() appends to observation store with auto-generated timestamp and sessionId
    - Test: generateProposals() detects divergences and creates proposals in the queue
    - Test: generateProposals() audit-logs each new proposal with cans_proposal_created
    - Test: resolveProposal('accept') writes to CANS.md, updates hash, audit-logs cans_proposal_accepted
    - Test: resolveProposal('reject') updates proposal status, audit-logs cans_proposal_rejected
    - Test: resolveProposal('defer') updates proposal status, audit-logs cans_proposal_deferred
    - Test: applyProposal rejects scope field changes (defense layer 3) — should throw
    - Test: applyProposal validates against CANSSchema before writing
    - Test: getPendingProposals returns pending and deferred proposals
    - Use mkdtempSync temp workspaces with real CANS.md files and real AuditPipeline (established integration test pattern)
    - Use the validCANSData fixture from test/fixtures/valid-cans-data.ts to create test CANS.md files
  </action>
  <verify>
    Run `npx vitest run test/unit/refinement/refinement-engine.test.ts` — all tests pass.
    Run `npx vitest run test/unit/refinement/` — all refinement tests pass (including Plan 01 tests).
    Grep for `isScopeField` in refinement-engine.ts — must be present (defense layer 3).
    Grep for `updateKnownGoodHash` in refinement-engine.ts — must be present (integrity preservation).
    Grep for `cans_proposal_` in refinement-engine.ts — must appear for all 4 lifecycle actions (created, accepted, rejected, deferred).
  </verify>
  <done>
    RefinementEngine composes all components with a clean public API. Accepted proposals modify CANS.md through the parse/validate/write/hash chain. Every lifecycle event (created, accepted, rejected, deferred) is audit-logged. Scope fields are protected by a third independent safety layer.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create CLI proposals command and wire refinement into entry points</name>
  <files>
    src/cli/proposals-command.ts
    src/cli/commands.ts
    src/entry/openclaw.ts
    src/entry/standalone.ts
    src/entry/core.ts
    test/unit/refinement/proposals-command.test.ts
  </files>
  <action>
    Create `src/cli/proposals-command.ts`:
    - Export `runProposalsCommand(engine: RefinementEngine, io: InterviewIO): Promise<void>`
    - Import `InterviewIO` from `./io.js` and `RefinementEngine` from `../refinement/index.js`
    - Import `generateDiffView` from `../refinement/index.js`
    - Implementation flow:
      1. First, call `engine.generateProposals()` to detect any new proposals from accumulated observations
      2. Call `engine.getPendingProposals()` to get all reviewable proposals
      3. If no proposals: `io.output('No pending CANS.md refinement proposals.')` and return
      4. Show batch summary via `io.output`:
         ```
         CANS.md Refinement Proposals ({count} pending)
         ================================================
         {for each proposal: "{i}. [{status}] {field_path}: {evidence_summary}"}
         ```
      5. For each proposal, present detail view:
         ```
         Proposal {i}/{total}: {field_path}
         ---
         {evidence_summary}

         {generateDiffView(proposal)}

         Action: [A]ccept / [R]eject / [D]efer / [S]kip
         ```
      6. Read provider action via `io.askText('Action', ...)`. Accept inputs: 'a'/'accept', 'r'/'reject', 'd'/'defer', 's'/'skip' (case-insensitive). Skip moves to next proposal without resolving.
      7. For accept/reject/defer: call `engine.resolveProposal(proposal.id, action)`
      8. After each resolution, output confirmation: `"Proposal {action}ed: {field_path}"`
      9. After all proposals: output summary: `"Reviewed {count} proposal(s): {accepted} accepted, {rejected} rejected, {deferred} deferred, {skipped} skipped"`

    Modify `src/cli/commands.ts`:
    - Add import: `import { runProposalsCommand } from './proposals-command.js'`
    - Add import: `import type { RefinementEngine } from '../refinement/index.js'`
    - Change `registerCLI` signature to accept optional `refinement?: RefinementEngine` as fourth parameter
    - Add new CLI command registration after the existing two commands:
      ```typescript
      if (refinement) {
        adapter.registerCliCommand({
          name: 'careagent proposals',
          description: 'Review and act on CANS.md refinement proposals',
          handler: async () => {
            const io = createTerminalIO();
            await runProposalsCommand(refinement, io);
          },
        });
      }
      ```

    Modify `src/entry/openclaw.ts`:
    - Add import: `import { createRefinementEngine } from '../refinement/index.js'`
    - After Step 6.5 (skill loading, before Step 7), add Step 6.7:
      ```typescript
      // Step 6.7: Create refinement engine (CANS-08, CANS-09, CANS-10)
      const refinement = createRefinementEngine({
        workspacePath,
        audit,
        sessionId: audit.getSessionId(),
      });
      ```
    - Modify Step 3 (registerCLI call) to pass `undefined` for refinement initially — OR better: move registerCLI call to after refinement engine creation. Actually, CLI must be registered early (before activation check, needed for `careagent init` without CANS.md). So keep the early registerCLI call as-is, but add a SECOND registerCliCommand call for proposals after refinement engine is created:
      ```typescript
      // Step 6.7: Register refinement engine and proposals command
      const refinement = createRefinementEngine({ workspacePath, audit, sessionId: audit.getSessionId() });
      adapter.registerCliCommand({
        name: 'careagent proposals',
        description: 'Review and act on CANS.md refinement proposals',
        handler: async () => {
          const { createTerminalIO } = await import('../cli/io.js');
          const { runProposalsCommand } = await import('../cli/proposals-command.js');
          const io = createTerminalIO();
          await runProposalsCommand(refinement, io);
        },
      });
      ```
      This avoids modifying the registerCLI signature (which is a shared function).

    Modify `src/entry/standalone.ts`:
    - Add import: `import { createRefinementEngine } from '../refinement/index.js'`
    - Add import: `import type { RefinementEngine } from '../refinement/refinement-engine.js'`
    - Add `refinement?: RefinementEngine` to `ActivateResult` interface
    - After hardening engine activation and skill loading, create refinement engine:
      ```typescript
      const refinement = createRefinementEngine({
        workspacePath: resolvedPath,
        audit,
        sessionId: audit.getSessionId(),
      });
      ```
    - Return `refinement` in the active result: `return { adapter, audit, activation, engine, skills, refinement }`

    Modify `src/entry/core.ts`:
    - Add refinement re-exports section:
      ```typescript
      // Refinement (implementation — Phase 5)
      export type { RefinementEngine, Observation, Proposal, DivergencePattern, ObservationCategory, ProposalResolution } from '../refinement/index.js';
      export { createRefinementEngine, DEFAULT_DIVERGENCE_THRESHOLD, RESURFACE_THRESHOLD, SACROSANCT_FIELDS, isScopeField } from '../refinement/index.js';
      export { ObservationStore } from '../refinement/index.js';
      export { ProposalQueue } from '../refinement/index.js';
      export { detectDivergences } from '../refinement/index.js';
      export { generateDiffView } from '../refinement/index.js';
      ```

    Create unit tests in `test/unit/refinement/proposals-command.test.ts`:
    - Create a mock RefinementEngine with controllable getPendingProposals and resolveProposal
    - Create a mock IO (same pattern as onboarding tests — capture output array, provide input responses)
    - Test: No proposals outputs "No pending" message
    - Test: Batch summary shows all proposals
    - Test: Accept action calls resolveProposal with 'accept'
    - Test: Reject action calls resolveProposal with 'reject'
    - Test: Defer action calls resolveProposal with 'defer'
    - Test: Skip action does not call resolveProposal
    - Test: Summary counts are correct after review
  </action>
  <verify>
    Run `npx vitest run test/unit/refinement/proposals-command.test.ts` — all tests pass.
    Run `npx vitest run test/unit/refinement/` — all refinement unit tests pass.
    Run `npx vitest run` — full test suite passes (no regressions).
    Grep for `createRefinementEngine` in openclaw.ts and standalone.ts — both present.
    Grep for `refinement` in core.ts — re-exports present.
    Verify `npx tsdown` build succeeds with all 4 entry points.
  </verify>
  <done>
    CLI `careagent proposals` command presents proposals in batch with Accept/Reject/Defer/Skip actions. Refinement engine is created in both openclaw.ts and standalone.ts entry points. core.ts re-exports the full refinement public API. All existing tests continue to pass with zero regressions.
  </done>
</task>

</tasks>

<verification>
- `npx vitest run test/unit/refinement/` — all refinement unit tests pass
- `npx vitest run` — full test suite passes (no regressions from entry point changes)
- `npx tsdown` — build succeeds with all 4 entry points
- Audit logging: grep for `cans_proposal_created`, `cans_proposal_accepted`, `cans_proposal_rejected`, `cans_proposal_deferred` in refinement-engine.ts
- Scope protection: `isScopeField` appears in refinement-engine.ts (defense layer 3)
- `updateKnownGoodHash` called in applyProposal (integrity preservation)
- `careagent proposals` command registered in openclaw.ts
- `RefinementEngine` exported from core.ts
</verification>

<success_criteria>
- RefinementEngine API is complete with observe, generateProposals, getPendingProposals, resolveProposal
- Accepted proposals correctly modify CANS.md with schema validation and integrity hash update
- Every proposal lifecycle event creates an audit log entry
- CLI command presents proposals in batch with all three resolution actions
- Entry points create and expose the refinement engine
- Full test suite passes with zero regressions
</success_criteria>

<output>
After completion, create `.planning/phases/05-cans-continuous-improvement-and-integration/05-02-SUMMARY.md`
</output>
